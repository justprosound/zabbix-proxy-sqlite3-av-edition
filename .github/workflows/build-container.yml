name: 'Build and Publish Container'

# This workflow is designed to work with minimal permissions.
# When called from other workflows, dependency snapshot submission may be skipped
# due to permission restrictions, which is normal and expected behavior.

on:
  workflow_call:
    inputs:
      zabbix_version:
        required: true
        type: string
      major_minor:
        required: true
        type: string
      is_lts:
        required: false
        type: string
        default: 'false'
        description: "Whether this is an LTS version (as a string 'true' or 'false')"
      latest_version:
        required: true
        type: string
        description: "The highest Zabbix version number (e.g., 7.2.7 > 7.0.13)"
    outputs:
      release_id:
        description: "Created GitHub Release ID"
        value: ${{ jobs.build-container.outputs.release_id }}
      release_tag:
        description: "Created GitHub Release Tag"
        value: ${{ jobs.build-container.outputs.release_tag }}

jobs:
  build-container:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
      id-token: write
      actions: read
      security-events: write
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      release_tag: ${{ steps.local_version.outputs.local_version }}
    env:
      # Default to REPO_NAME from parent workflow or use the full repository name if not set
      IMAGE_NAME: ${{ vars.REPO_NAME || 'zabbix-proxy-sqlite3-av-edition' }}
      # Define the base name for documentation
      BASE_NAME: ${{ vars.BASE_NAME || 'Zabbix Proxy SQLite3 AV Edition' }}
    steps:
      - uses: actions/checkout@v4

      # Security: Verify checkout integrity
      - name: Verify repository integrity
        run: |
          echo "Verifying repository state..."
          git fsck --no-progress --no-dangling
          echo "Repository integrity check passed"

      # Analyze repository and determine appropriate image name
      - name: Determine repository and image names
        id: repo_analysis
        run: |
          # Get actual repository name from github.repository
          ACTUAL_REPO="${{ github.repository }}"
          ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"
          REPO_OWNER="${{ github.repository_owner }}"

          echo "Repository: $ACTUAL_REPO"
          echo "Repository Owner: $REPO_OWNER"
          echo "Repository Name: $ACTUAL_REPO_NAME"

          # Check if we need to adjust the image name based on repo name
          IMAGE_NAME="${{ env.IMAGE_NAME }}"

          # Default registry - hardcode to ghcr.io for security
          REGISTRY="ghcr.io"

          if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
            echo "Repository name differs from default template"
            # Try to extract a meaningful name - remove common prefixes/suffixes
            CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
            # If we have a cleaned name that's different and not empty, use it as a prefix
            if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" && "$CLEANED_NAME" != "-" ]]; then
              # Only add prefix if it makes sense
              if [[ "$IMAGE_NAME" != *"$CLEANED_NAME"* ]]; then
                IMAGE_NAME="${CLEANED_NAME}-${IMAGE_NAME}"
                echo "Adjusted image name to: $IMAGE_NAME"
              fi
            fi
          fi

          echo "Final image name: $IMAGE_NAME"
          echo "Final registry: $REGISTRY"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${ACTUAL_REPO_NAME}" >> $GITHUB_OUTPUT

      # Generate reproducible build timestamp in ISO-8601 format
      - name: Generate build timestamp
        id: build_timestamp
        run: echo "DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:latest

      # Verify that the upstream Zabbix image exists before proceeding
      - name: Verify upstream Zabbix image exists
        id: check_upstream_image
        continue-on-error: true
        run: |
          UPSTREAM_IMAGE="zabbix/zabbix-proxy-sqlite3:ubuntu-${{ inputs.zabbix_version }}"
          echo "Checking if upstream image exists: $UPSTREAM_IMAGE"

          # Attempt to pull the image to verify it exists
          if docker pull "$UPSTREAM_IMAGE" &>/dev/null; then
            echo "✅ Upstream image $UPSTREAM_IMAGE exists and is accessible"
            echo "upstream_exists=true" >> $GITHUB_OUTPUT
          else
            echo "❌ ERROR: Upstream image $UPSTREAM_IMAGE does not exist or is not accessible"
            echo "::warning::Upstream image $UPSTREAM_IMAGE not found! Build will likely fail."
            echo "upstream_exists=false" >> $GITHUB_OUTPUT

            # Add information to step summary
            echo "## ⚠️ Upstream Image Verification Failed" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Details |" >> $GITHUB_STEP_SUMMARY
            echo "| ------ | ------- |" >> $GITHUB_STEP_SUMMARY
            echo "| ❌ Failed | Upstream image \`$UPSTREAM_IMAGE\` does not exist or is not accessible |" >> $GITHUB_STEP_SUMMARY
            echo "| 📝 Impact | The build will likely fail as it depends on this base image |" >> $GITHUB_STEP_SUMMARY
            echo "| 🔍 Resolution | Verify that the Zabbix version specified is correct and available |" >> $GITHUB_STEP_SUMMARY
          fi

      # Security: Use OIDC token instead of PAT when possible
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Determine local version based on changes in the repository
      - name: Get local version with patch increment if needed
        id: local_version
        run: |
          ZABBIX_VERSION="${{ inputs.zabbix_version }}"

          # Initialize values - use base version until determined otherwise
          LOCAL_VERSION="$ZABBIX_VERSION"
          IS_LOCAL_CHANGE=false

          # Check if there are existing tags for this version
          git fetch --tags
          EXISTING_TAGS=$(git tag -l "$ZABBIX_VERSION*" | sort -V)
          echo "Found existing tags: $EXISTING_TAGS"

          # Check for local modifications since the last tag
          LAST_TAG=$(echo "$EXISTING_TAGS" | tail -n 1)
          if [[ -n "$LAST_TAG" ]]; then
            echo "Last tag for this version: $LAST_TAG"

            # Check if Dockerfile or scripts have changed
            CHANGED_FILES=$(git diff --name-only $LAST_TAG HEAD -- Dockerfile scripts)
            if [[ -n "$CHANGED_FILES" ]]; then
              echo "Local changes detected since last build:"
              echo "$CHANGED_FILES"

              # Get the highest N value from existing X.Y.Z.N tags
              HIGHEST_N=0
              for TAG in $EXISTING_TAGS; do
                if [[ $TAG =~ ^${ZABBIX_VERSION}\.[0-9]+$ ]]; then
                  N_VALUE=$(echo "$TAG" | cut -d. -f4)
                  if [[ $N_VALUE -gt $HIGHEST_N ]]; then
                    HIGHEST_N=$N_VALUE
                  fi
                fi
              done

              # Increment N for the new local version
              NEW_N=$(($HIGHEST_N + 1))
              LOCAL_VERSION="$ZABBIX_VERSION.$NEW_N"
              IS_LOCAL_CHANGE=true

              echo "Using local version: $LOCAL_VERSION due to detected changes"
            fi
          fi

          # Set outputs
          echo "local_version=$LOCAL_VERSION" >> $GITHUB_OUTPUT
          echo "is_local_change=$IS_LOCAL_CHANGE" >> $GITHUB_OUTPUT

          # Add to step summary
          echo "## Version Information" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| ----------- | ----- |" >> $GITHUB_STEP_SUMMARY
          echo "| Upstream Zabbix Version | $ZABBIX_VERSION |" >> $GITHUB_STEP_SUMMARY
          echo "| Local Version | $LOCAL_VERSION |" >> $GITHUB_STEP_SUMMARY
          echo "| Local Changes | $IS_LOCAL_CHANGE |" >> $GITHUB_STEP_SUMMARY

      # Determine tagging strategy for this version
      - name: Version tag management
        id: version_tag_management
        run: |
          ZABBIX_VERSION="${{ inputs.zabbix_version }}"
          MAJOR_MINOR="${{ inputs.major_minor }}"
          LATEST_VERSION="${{ inputs.latest_version }}"

          echo "Current version: $ZABBIX_VERSION"
          echo "Major.minor series: $MAJOR_MINOR"
          echo "Latest version (highest overall): $LATEST_VERSION"

          # Default values
          SHOULD_TAG_LATEST="false"

          # Check if this is the highest version overall - only this one gets the 'latest' tag
          if [ "$ZABBIX_VERSION" == "$LATEST_VERSION" ]; then
            echo "✅ This is the highest version overall ($ZABBIX_VERSION) - will apply 'latest' tag"
            SHOULD_TAG_LATEST="true"
          else
            echo "❌ Not the highest version overall (which is $LATEST_VERSION) - will NOT apply 'latest' tag"
          fi

          # Set output values for use in later steps
          echo "should_tag_latest=$SHOULD_TAG_LATEST" >> $GITHUB_OUTPUT

          # Determine if this is an LTS version
          IS_LTS="${{ inputs.is_lts }}"

          if [ "$IS_LTS" == "true" ]; then
            echo "✅ This is an LTS version ($MAJOR_MINOR series) - will apply 'lts' tag"
            echo "is_lts=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Not an LTS version - will NOT apply 'lts' tag"
            echo "is_lts=false" >> $GITHUB_OUTPUT
          fi

          # Add information to step summary
          echo "## 🏷️ Version Tag Management" >> $GITHUB_STEP_SUMMARY
          echo "| Version Type | Value | Tag Status |" >> $GITHUB_STEP_SUMMARY
          echo "| ------------ | ----- | ---------- |" >> $GITHUB_STEP_SUMMARY
          echo "| Current Version | $ZABBIX_VERSION | Will tag as \`$ZABBIX_VERSION\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Major.Minor | $MAJOR_MINOR | Will tag as \`$MAJOR_MINOR\` |" >> $GITHUB_STEP_SUMMARY

          if [ "$SHOULD_TAG_LATEST" == "true" ]; then
            echo "| Latest | $LATEST_VERSION | ✅ Will tag as \`latest\` (highest version overall) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Latest | $LATEST_VERSION | ❌ Will NOT tag as \`latest\` (reserved for $LATEST_VERSION) |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$IS_LTS" == "true" ]; then
            echo "| LTS | $MAJOR_MINOR | ✅ Will tag as \`lts\` (LTS version) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| LTS | N/A | ❌ Will NOT tag as \`lts\` (not an LTS version) |" >> $GITHUB_STEP_SUMMARY
          fi

      # Security: Scan Dockerfile for vulnerabilities before building
      - name: Run Anchore scan-action on Dockerfile
        id: dockerfile_scan
        uses: anchore/scan-action@v6
        if: success() && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        with:
          path: "."
          fail-build: false
          severity-cutoff: high
          output-format: sarif

      # Upload Dockerfile scan results to GitHub Security tab
      - name: Upload Dockerfile scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: success() && steps.dockerfile_scan.outcome == 'success' && steps.dockerfile_scan.conclusion == 'success'
        with:
          sarif_file: ${{ steps.dockerfile_scan.outputs.sarif }}
          category: "dockerfile-vulnerabilities"

      # Generate vulnerability summary for Dockerfile
      - name: Generate Dockerfile vulnerability summary
        if: success() && steps.dockerfile_scan.outcome == 'success' && steps.dockerfile_scan.conclusion == 'success'
        run: |
          echo "## Dockerfile Vulnerability Scan Results" >> $GITHUB_STEP_SUMMARY

          if [[ -f "${{ steps.dockerfile_scan.outputs.sarif }}" ]]; then
            VULN_COUNT=$(jq -r '.runs[].results | length' ${{ steps.dockerfile_scan.outputs.sarif }} || echo "0")
            echo "| Category | Count |" >> $GITHUB_STEP_SUMMARY
            echo "| -------- | ----- |" >> $GITHUB_STEP_SUMMARY
            echo "| Total Vulnerabilities | $VULN_COUNT |" >> $GITHUB_STEP_SUMMARY

            if [ "$VULN_COUNT" -gt 0 ]; then
              echo "::warning::Found $VULN_COUNT potential security vulnerabilities in Dockerfile"
            else
              echo "✅ No vulnerabilities found in Dockerfile" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No vulnerability data available" >> $GITHUB_STEP_SUMMARY
          fi


      # Build image only (do not push yet)
      - name: Build image (no push)
        id: build_image
        if: success() && (steps.check_upstream_image.outputs.upstream_exists != 'false')
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          provenance: mode=max
          sbom: true
          platforms: linux/amd64
          outputs: type=docker
          file: ./Dockerfile
          secrets: |
            "github_token=${{ secrets.GITHUB_TOKEN }}"
          build-args: |
            ZABBIX_VERSION=ubuntu-${{ inputs.zabbix_version }}
            BUILD_DATE=${{ steps.build_timestamp.outputs.DATE }}
            VCS_REF=${{ github.sha }}
          tags: |
            ${{
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                steps.local_version.outputs.local_version
              )
            }}
            ${{
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                inputs.major_minor
              )
            }}
            ${{
              steps.local_version.outputs.is_local_change == 'false' &&
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                inputs.zabbix_version
              ) || ''
            }}
            ${{
              inputs.is_lts == 'true' &&
              format(
                '{0}/{1}/{2}:lts',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name
              ) || ''
            }}
            ${{
              steps.version_tag_management.outputs.should_tag_latest == 'true' &&
              format(
                '{0}/{1}/{2}:latest',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name
              ) || ''
            }}
          labels: |
            org.opencontainers.image.title=Zabbix Proxy SQLite3 for AV Systems
            org.opencontainers.image.description=Zabbix Proxy SQLite3 for AV Systems
            org.opencontainers.image.version=${{ inputs.zabbix_version }}
            org.opencontainers.image.base.name=zabbix/zabbix-proxy-sqlite3
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.created=${{ steps.build_timestamp.outputs.DATE }}
            org.opencontainers.image.authors=${{ github.repository_owner }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.licenses=AGPL-3.0
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/README.md
            org.zabbix.upstream.version=${{ inputs.zabbix_version }}
            org.zabbix.local.version=${{ steps.local_version.outputs.local_version }}
            org.zabbix.build.date=${{ steps.build_timestamp.outputs.DATE }}
            org.zabbix.vcs.ref=${{ github.sha }}
            org.zabbix.container.immutable=true

      # ...existing scan, SBOM, and validation steps...

      # Push image only if all checks pass
      - name: Push image
        id: push_image
        if: success() && (steps.check_upstream_image.outputs.upstream_exists != 'false')
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          provenance: mode=max
          sbom: true
          platforms: linux/amd64
          outputs: type=image
          file: ./Dockerfile
          secrets: |
            "github_token=${{ secrets.GITHUB_TOKEN }}"
          build-args: |
            ZABBIX_VERSION=ubuntu-${{ inputs.zabbix_version }}
            BUILD_DATE=${{ steps.build_timestamp.outputs.DATE }}
            VCS_REF=${{ github.sha }}
          tags: |
            ${{
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                steps.local_version.outputs.local_version
              )
            }}
            ${{
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                inputs.major_minor
              )
            }}
            ${{
              steps.local_version.outputs.is_local_change == 'false' &&
              format(
                '{0}/{1}/{2}:{3}',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name,
                inputs.zabbix_version
              ) || ''
            }}
            ${{
              inputs.is_lts == 'true' &&
              format(
                '{0}/{1}/{2}:lts',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name
              ) || ''
            }}
            ${{
              steps.version_tag_management.outputs.should_tag_latest == 'true' &&
              format(
                '{0}/{1}/{2}:latest',
                steps.repo_analysis.outputs.registry,
                github.repository_owner,
                steps.repo_analysis.outputs.image_name
              ) || ''
            }}
          labels: |
            org.opencontainers.image.title=Zabbix Proxy SQLite3 for AV Systems
            org.opencontainers.image.description=Zabbix Proxy SQLite3 for AV Systems
            org.opencontainers.image.version=${{ inputs.zabbix_version }}
            org.opencontainers.image.base.name=zabbix/zabbix-proxy-sqlite3
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.created=${{ steps.build_timestamp.outputs.DATE }}
            org.opencontainers.image.authors=${{ github.repository_owner }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.licenses=AGPL-3.0
            org.opencontainers.image.documentation=${{ github.server_url }}/${{ github.repository }}/blob/main/README.md
            org.zabbix.upstream.version=${{ inputs.zabbix_version }}
            org.zabbix.local.version=${{ steps.local_version.outputs.local_version }}
            org.zabbix.build.date=${{ steps.build_timestamp.outputs.DATE }}
            org.zabbix.vcs.ref=${{ github.sha }}
            org.zabbix.container.immutable=true

      # Record build attempt status with upstream verification results
      - name: Record build attempt status
        if: always()
        run: |
          echo "## 🏗️ Build Attempt Status" >> $GITHUB_STEP_SUMMARY

          # Check if upstream verification was successful
          if [[ "${{ steps.check_upstream_image.outputs.upstream_exists }}" == "false" ]]; then
            echo "| ❌ Stopped | Build was skipped because upstream image verification failed |" >> $GITHUB_STEP_SUMMARY
            echo "| 🔍 Resolution | Verify that Zabbix version ${{ inputs.zabbix_version }} exists in the Docker Hub registry |" >> $GITHUB_STEP_SUMMARY
            echo "| 🔎 Check | Use 'docker pull zabbix/zabbix-proxy-sqlite3:ubuntu-${{ inputs.zabbix_version }}' to verify |" >> $GITHUB_STEP_SUMMARY
            echo "| 📚 Reference | See available versions at [Docker Hub](https://hub.docker.com/r/zabbix/zabbix-proxy-sqlite3/tags) |" >> $GITHUB_STEP_SUMMARY
          else
            # Add build information only if build wasn't skipped
            echo "| ✅ Status | Build attempt proceeded with upstream image |" >> $GITHUB_STEP_SUMMARY
            # Construct image tag
            # Prepare image path for use in reporting
            REGISTRY="${{ steps.repo_analysis.outputs.registry }}"
            OWNER="${{ github.repository_owner }}"
            IMG_NAME="${{ steps.repo_analysis.outputs.image_name }}"
            VERSION="${{ steps.local_version.outputs.local_version }}"
            IMAGE_TAG="$REGISTRY/$OWNER/$IMG_NAME:$VERSION"
            echo "| 🏷️ Image Tag | $IMAGE_TAG |" >> $GITHUB_STEP_SUMMARY
            echo "| 📋 Zabbix Version | ${{ inputs.zabbix_version }} |" >> $GITHUB_STEP_SUMMARY
          fi

      # Security: Scan container for vulnerabilities
      - name: Run Trivy vulnerability scanner for ${{ steps.local_version.outputs.local_version }}
        uses: aquasecurity/trivy-action@master
        id: trivy_scan
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        with:
          # Defining the full image path
          image-ref: ${{ steps.repo_analysis.outputs.registry }}/${{ github.repository_owner }}/${{ steps.repo_analysis.outputs.image_name }}:${{ steps.local_version.outputs.local_version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      # Security: Upload vulnerability scan results
      - name: Upload Trivy scan results for ${{ steps.local_version.outputs.local_version }} to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: success() && steps.trivy_scan.outcome == 'success' && steps.trivy_scan.conclusion == 'success'
        with:
          sarif_file: 'trivy-results.sarif'

      # Security: Scan container for vulnerabilities using Anchore scan-action
      - name: Run Anchore vulnerability scanner for ${{ steps.local_version.outputs.local_version }}
        uses: anchore/scan-action@v6
        id: anchore_scan
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        with:
          image: ${{ steps.repo_analysis.outputs.registry }}/${{ github.repository_owner }}/${{ steps.repo_analysis.outputs.image_name }}:${{ steps.local_version.outputs.local_version }}
          fail-build: false
          severity-cutoff: high
          output-format: sarif
          add-cpes-if-none: true

      # Security: Upload Anchore scan results to GitHub Security tab
      - name: Upload Anchore scan results for ${{ steps.local_version.outputs.local_version }} to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: success() && steps.anchore_scan.outcome == 'success' && steps.anchore_scan.conclusion == 'success'
        with:
          sarif_file: ${{ steps.anchore_scan.outputs.sarif }}
          category: "anchore-${{ steps.local_version.outputs.local_version }}"

      # Generate vulnerability summary for container image
      - name: Generate vulnerability summary
        if: success() && steps.anchore_scan.outcome == 'success' && steps.anchore_scan.conclusion == 'success'
        run: |
          echo "## Container Image Vulnerability Scan Results" >> $GITHUB_STEP_SUMMARY

          if [[ -f "${{ steps.anchore_scan.outputs.sarif }}" ]]; then
            VULN_COUNT=$(jq -r '.runs[].results | length' ${{ steps.anchore_scan.outputs.sarif }} || echo "0")
            echo "| Category | Count |" >> $GITHUB_STEP_SUMMARY
            echo "| -------- | ----- |" >> $GITHUB_STEP_SUMMARY
            echo "| Total Vulnerabilities | $VULN_COUNT |" >> $GITHUB_STEP_SUMMARY

            if [[ "$VULN_COUNT" -gt 0 && -f "${{ steps.anchore_scan.outputs.json }}" ]]; then
              # Count by severity if JSON output is available
              echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
              echo "| -------- | ----- |" >> $GITHUB_STEP_SUMMARY

              for SEV in "Critical" "High" "Medium" "Low" "Negligible"; do
                # Convert severity to lowercase for jq comparison
                SEV_LOWER=$(echo $SEV | tr '[:upper:]' '[:lower:]')
                # Count vulnerabilities by severity
                COUNT=$(jq -r '.matches[] | select(.vulnerability.severity | ascii_downcase == "'$SEV_LOWER'") | .vulnerability.id' \
                  ${{ steps.anchore_scan.outputs.json }} 2>/dev/null | wc -l || echo "0")
                echo "| $SEV | $COUNT |" >> $GITHUB_STEP_SUMMARY
              done
            fi
          else
            echo "No vulnerability data available" >> $GITHUB_STEP_SUMMARY
          fi

      # Generate SPDX SBOM and submit to GitHub dependency graph
      - name: Generate SPDX SBOM for ${{ steps.local_version.outputs.local_version }}
        uses: aquasecurity/trivy-action@master
        id: spdx_sbom
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        with:
          # Defining the full image path
          image-ref: ${{ steps.repo_analysis.outputs.registry }}/${{ github.repository_owner }}/${{ steps.repo_analysis.outputs.image_name }}:${{ steps.local_version.outputs.local_version }}
          format: 'spdx-json'
          output: 'sbom-spdx.json'

      # Validate SPDX SBOM contents
      - name: Validate SPDX SBOM for ${{ steps.local_version.outputs.local_version }}
        id: validate_spdx_sbom
        if: success() && steps.spdx_sbom.outcome == 'success' && steps.spdx_sbom.conclusion == 'success'
        run: |
          echo "## SPDX SBOM Validation" >> $GITHUB_STEP_SUMMARY

          # Check if the file exists and has content
          if [ -f "sbom-spdx.json" ] && [ -s "sbom-spdx.json" ]; then
            echo ":white_check_mark: SPDX SBOM file exists and has content" >> $GITHUB_STEP_SUMMARY

            # Count packages
            PACKAGE_COUNT=$(jq '.packages | length' sbom-spdx.json)
            echo ":information_source: Contains information on $PACKAGE_COUNT packages" >> $GITHUB_STEP_SUMMARY

            # Check for critical tools
            for TOOL in "zabbix" "sqlite" "python" "snmp"; do
              if jq -e ".packages[] | select(.name | test(\"$TOOL\"; \"i\"))" sbom-spdx.json > /dev/null; then
                echo ":white_check_mark: Found SBOM entries related to: $TOOL" >> $GITHUB_STEP_SUMMARY
              else
                echo ":warning: No SBOM entries found for key component: $TOOL" >> $GITHUB_STEP_SUMMARY
              fi
            done
          else
            echo ":x: SPDX SBOM file is missing or empty" >> $GITHUB_STEP_SUMMARY
            echo "::warning::SPDX SBOM file is missing or empty"
          fi

      # Generate SBOM using Anchore SBOM Action with GitHub's built-in dependency snapshot support
      - name: Generate SBOM for ${{ steps.local_version.outputs.local_version }}
        uses: anchore/sbom-action@v0
        id: anchore_sbom_generation
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        with:
          # Defining the full image path
          image: ${{ steps.repo_analysis.outputs.registry }}/${{ github.repository_owner }}/${{ steps.repo_analysis.outputs.image_name }}:${{ steps.local_version.outputs.local_version }}
          artifact-name: sbom-${{ steps.local_version.outputs.local_version }}.spdx.json
          output-file: ./sbom-${{ steps.local_version.outputs.local_version }}.json
          format: cyclonedx-json
          # Try to use the built-in dependency snapshot if permissions allow, will silently skip if not available
          dependency-snapshot: true

      # Debug SBOM file format to help with troubleshooting
      - name: Debug SBOM file format
        if: success() && steps.anchore_sbom_generation.outcome == 'success' && steps.anchore_sbom_generation.conclusion == 'success'
        run: |
          SBOM_FILE="./sbom-${{ steps.local_version.outputs.local_version }}.json"
          echo "## SBOM File Format Debug" >> $GITHUB_STEP_SUMMARY

          if [ -f "$SBOM_FILE" ] && [ -s "$SBOM_FILE" ]; then
            echo "SBOM file exists and has content" >> $GITHUB_STEP_SUMMARY
            echo "File size: $(stat -c%s "$SBOM_FILE") bytes" >> $GITHUB_STEP_SUMMARY

            # Check if file is valid JSON
            if jq . "$SBOM_FILE" > /dev/null 2>&1; then
              echo ":white_check_mark: File is valid JSON" >> $GITHUB_STEP_SUMMARY

              # Extract key structure information for diagnosis
              echo "### SBOM Top-Level Structure" >> $GITHUB_STEP_SUMMARY
              echo '```json' >> $GITHUB_STEP_SUMMARY
              jq 'keys' "$SBOM_FILE" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY

              # Check if it has the expected CycloneDX format
              if jq -e '.bomFormat == "CycloneDX"' "$SBOM_FILE" > /dev/null; then
                echo ":white_check_mark: File follows CycloneDX format" >> $GITHUB_STEP_SUMMARY

                # Extract component count for reference
                COMPONENT_COUNT=$(jq '.components | length' "$SBOM_FILE")
                echo "Contains $COMPONENT_COUNT components" >> $GITHUB_STEP_SUMMARY

                # Sample first component for format inspection
                echo "### Sample Component Format" >> $GITHUB_STEP_SUMMARY
                echo '```json' >> $GITHUB_STEP_SUMMARY
                jq '.components[0]' "$SBOM_FILE" >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
              else
                echo ":warning: File doesn't follow expected CycloneDX format" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo ":x: File is not valid JSON" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo ":x: SBOM file is missing or empty" >> $GITHUB_STEP_SUMMARY
          fi

      # Process SBOM and submit to GitHub dependency graph - Enhanced with robust error handling
      - name: Process and submit dependency snapshot for ${{ steps.local_version.outputs.local_version }}
        id: dependency_snapshot
        if: success() && steps.anchore_sbom_generation.outcome == 'success' && steps.anchore_sbom_generation.conclusion == 'success'
        continue-on-error: true
        run: |
          echo "Processing SBOM for dependency graph submission..."
          SBOM_FILE="./sbom-${{ steps.local_version.outputs.local_version }}.json"
          EXIT_CODE=0
          SUBMISSION_STATUS="not_attempted"

          # Create debug directory for advanced diagnostics
          mkdir -p /tmp/dependency-snapshot-debug

          if [ -f "$SBOM_FILE" ]; then
            # Copy original SBOM for diagnostics
            cp "$SBOM_FILE" "/tmp/dependency-snapshot-debug/original-sbom.json"

            # Validate the SBOM file structure before processing
            echo "Validating SBOM format..."
            if ! jq . "$SBOM_FILE" > /dev/null 2>&1; then
              JQ_ERROR=$(jq . "$SBOM_FILE" 2>&1)
              echo "::warning::SBOM file is not valid JSON. Cannot create dependency snapshot."
              echo ":x: SBOM file is not valid JSON. Cannot create dependency snapshot." >> $GITHUB_STEP_SUMMARY
              echo "Error details: $JQ_ERROR" >> $GITHUB_STEP_SUMMARY
              SUBMISSION_STATUS="invalid_sbom"
              EXIT_CODE=1
            else
              # Log basic SBOM structure for debugging
              echo "SBOM Format: $(jq -r '.bomFormat // "unknown"' $SBOM_FILE)" >> /tmp/dependency-snapshot-debug/sbom-info.txt
              echo "SBOM Components Count: $(jq -r '.components | length // 0' $SBOM_FILE)" >> /tmp/dependency-snapshot-debug/sbom-info.txt
              echo "Zabbix Version: ${{ inputs.zabbix_version }}" >> /tmp/dependency-snapshot-debug/sbom-info.txt

              # Create a formatted JSON file for dependency submission
              echo "Creating dependency snapshot JSON..."

              # Verify CycloneDX format first
              if jq -e '.bomFormat == "CycloneDX"' "$SBOM_FILE" > /dev/null; then
                echo "SBOM is in CycloneDX format - proceeding with transformation" >> /tmp/dependency-snapshot-debug/sbom-info.txt

                # First, simplify the SBOM to reduce size and avoid validation errors
                # Keep only essential fields for dependency detection
                jq -c '{
                  bomFormat,
                  specVersion,
                  version,
                  metadata: {
                    component: {
                      name,
                      version
                    }
                  },
                  components: [
                    .components[] |
                    select(.name != null and .version != null) |
                    {
                      name,
                      version,
                      purl: (.purl // null),
                      type: (.type // "library")
                    }
                  ][0:500]
                }' "$SBOM_FILE" > "simplified-sbom.json"

                # Save simplified SBOM for diagnostics
                cp "simplified-sbom.json" "/tmp/dependency-snapshot-debug/"

                # Count components before and after simplification for debugging
                ORIG_COMPONENTS=$(jq '.components | length' "$SBOM_FILE")
                SIMPLIFIED_COMPONENTS=$(jq '.components | length' "simplified-sbom.json")
                echo "Original components: $ORIG_COMPONENTS, Simplified components: $SIMPLIFIED_COMPONENTS" >> /tmp/dependency-snapshot-debug/sbom-info.txt

                # Create the dependency snapshot with the simplified SBOM
                echo "Creating dependency snapshot with version-neutral format..."
                jq -n \
                  --arg version "${{ steps.local_version.outputs.local_version }}" \
                  --arg job "${{ github.job }}" \
                  --arg sha "${{ github.sha }}" \
                  --arg ref "${{ github.ref }}" \
                  --arg zabbix_version "${{ inputs.zabbix_version }}" \
                  --argjson detector "{\"name\": \"anchore-sbom-zabbix\", \"version\": \"${{ steps.local_version.outputs.local_version }}\"}" \
                  --slurpfile sbom "simplified-sbom.json" \
                  '{
                    "version": 0,
                    "sha": $sha,
                    "ref": $ref,
                    "job": $job,
                    "detector": $detector,
                    "metadata": {
                      "buildTarget": $version,
                      "zabbixVersion": $zabbix_version
                    },
                    "manifests": $sbom
                  }' > dependency-snapshot.json

                # Save dependency snapshot for diagnostics
                cp "dependency-snapshot.json" "/tmp/dependency-snapshot-debug/"

                # Validate the dependency snapshot JSON
                if ! jq . dependency-snapshot.json > /dev/null 2>&1; then
                  SNAPSHOT_ERROR=$(jq . dependency-snapshot.json 2>&1)
                  echo "::warning::Generated dependency snapshot is not valid JSON. Cannot submit to GitHub."
                  echo ":x: Generated dependency snapshot is not valid JSON. Cannot submit to GitHub." >> $GITHUB_STEP_SUMMARY
                  echo "Error details: $SNAPSHOT_ERROR" >> $GITHUB_STEP_SUMMARY
                  SUBMISSION_STATUS="invalid_snapshot"
                  EXIT_CODE=2
                else
                  # Add debug information to help diagnose potential issues - avoid exceeding step summary limits
                  echo "## Dependency Snapshot Structure" >> $GITHUB_STEP_SUMMARY
                  # Extract only key structure information to prevent step summary size limit issues
                  SNAPSHOT_SUMMARY=$(jq -c '{version, sha, ref, job, detector, metadata, "manifest_count": (.manifests | length)}' dependency-snapshot.json)
                  echo "Basic structure: $SNAPSHOT_SUMMARY" >> $GITHUB_STEP_SUMMARY

                  # Verify snapshot size and warn if it's too large
                  SNAPSHOT_SIZE=$(stat -c%s "dependency-snapshot.json")
                  echo "Snapshot size: $SNAPSHOT_SIZE bytes" >> $GITHUB_STEP_SUMMARY
                  if [ "$SNAPSHOT_SIZE" -gt 1000000 ]; then
                    echo "::warning::Dependency snapshot is very large ($SNAPSHOT_SIZE bytes). This may cause API submission issues."
                    echo ":warning: Dependency snapshot is very large ($SNAPSHOT_SIZE bytes). This may cause submission issues." >> $GITHUB_STEP_SUMMARY

                    # Try to reduce size further for large snapshots
                    echo "Attempting to reduce snapshot size further..." >> $GITHUB_STEP_SUMMARY
                    jq -c '{
                      bomFormat,
                      specVersion,
                      version,
                      metadata: {
                        component: {
                          name,
                          version
                        }
                      },
                      components: [
                        .components[] |
                        select(.name != null and .version != null) |
                        {
                          name,
                          version,
                          type: (.type // "library")
                        }
                      ][0:250]
                    }' "$SBOM_FILE" > "reduced-sbom.json"

                    # Create a more compact dependency snapshot
                    jq -n \
                      --arg version "${{ steps.local_version.outputs.local_version }}" \
                      --arg job "${{ github.job }}" \
                      --arg sha "${{ github.sha }}" \
                      --arg ref "${{ github.ref }}" \
                      --arg zabbix_version "${{ inputs.zabbix_version }}" \
                      --argjson detector "{\"name\": \"anchore-sbom-zabbix\", \"version\": \"${{ steps.local_version.outputs.local_version }}\"}" \
                      --slurpfile sbom "reduced-sbom.json" \
                      '{
                        "version": 0,
                        "sha": $sha,
                        "ref": $ref,
                        "job": $job,
                        "detector": $detector,
                        "metadata": {
                          "buildTarget": $version,
                          "zabbixVersion": $zabbix_version
                        },
                        "manifests": $sbom
                      }' > dependency-snapshot-reduced.json

                    # If the reduced version is valid and smaller, use it instead
                    if jq . dependency-snapshot-reduced.json > /dev/null 2>&1; then
                      REDUCED_SIZE=$(stat -c%s "dependency-snapshot-reduced.json")
                      if [ "$REDUCED_SIZE" -lt "$SNAPSHOT_SIZE" ]; then
                        echo "Using reduced snapshot: $REDUCED_SIZE bytes (reduced from $SNAPSHOT_SIZE bytes)" >> $GITHUB_STEP_SUMMARY
                        mv dependency-snapshot-reduced.json dependency-snapshot.json
                        SNAPSHOT_SIZE=$REDUCED_SIZE
                      else
                        echo "Reduced snapshot not smaller, keeping original" >> $GITHUB_STEP_SUMMARY
                      fi
                    fi
                  fi

                  # Check token permissions first with detailed error handling
                  echo "Checking GitHub token permissions..."
                  TOKEN_CHECK=$(curl -s -S -f -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github+json" \
                    -w "\n%{http_code}" \
                    "${{ github.api_url }}/repos/${{ github.repository }}")

                  TOKEN_HTTP_STATUS=$(echo "$TOKEN_CHECK" | tail -n1)
                  TOKEN_BODY=$(echo "$TOKEN_CHECK" | sed '$d')

                  # Save token check results for diagnostics
                  echo "Token check HTTP status: $TOKEN_HTTP_STATUS" > /tmp/dependency-snapshot-debug/token-check.txt

                  if [ "$TOKEN_HTTP_STATUS" = "200" ]; then
                    # Extract permissions from token info - avoid exceeding step summary limits
                    if echo "$TOKEN_BODY" | jq -e '.permissions' > /dev/null; then
                      echo "## GitHub Token Permissions" >> $GITHUB_STEP_SUMMARY
                      PERMISSIONS_SUMMARY=$(echo "$TOKEN_BODY" | jq -c '.permissions')
                      echo "Permissions: $PERMISSIONS_SUMMARY" >> $GITHUB_STEP_SUMMARY

                      # Check specifically for dependency_graph write permission
                      if echo "$TOKEN_BODY" | jq -e '.permissions.dependency_graph' > /dev/null; then
                        DEP_GRAPH_PERMISSION=$(echo "$TOKEN_BODY" | jq -r '.permissions.dependency_graph')
                        echo "dependency_graph permission: $DEP_GRAPH_PERMISSION" >> $GITHUB_STEP_SUMMARY

                        if [ "$DEP_GRAPH_PERMISSION" != "write" ]; then
                          echo "::warning::Token does not have 'write' permission for dependency_graph" >> $GITHUB_STEP_SUMMARY
                        fi
                      else
                        echo "::warning::No explicit dependency_graph permission found" >> $GITHUB_STEP_SUMMARY
                      fi
                    else
                      echo ":warning: Could not retrieve permissions for GitHub token" >> $GITHUB_STEP_SUMMARY
                    fi

                    # Submit the snapshot to GitHub API with improved error handling
                    echo "Submitting dependency snapshot for Zabbix ${{ inputs.zabbix_version }} to GitHub..."
                    RESPONSE=$(curl -v -s -X POST \
                      -H "Accept: application/vnd.github+json" \
                      -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                      -H "X-GitHub-Api-Version: 2022-11-28" \
                      -H "Content-Type: application/json" \
                      "${{ github.api_url }}/repos/${{ github.repository }}/dependency-graph/snapshots" \
                      -d @dependency-snapshot.json \
                      -w "\n%{http_code}" 2> /tmp/dependency-snapshot-debug/curl-verbose.log)

                    # Extract HTTP status code and response body
                    HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
                    RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

                    # Save response for diagnostics
                    echo "$RESPONSE_BODY" > /tmp/dependency-snapshot-debug/api-response.json
                    echo "HTTP Status: $HTTP_STATUS" >> /tmp/dependency-snapshot-debug/api-response.json

                    # Check if submission was successful
                    if [[ "$HTTP_STATUS" =~ ^2[0-9][0-9]$ ]]; then
                      echo ":white_check_mark: Processed SBOM and submitted dependency snapshot for Zabbix ${{ inputs.zabbix_version }} to GitHub successfully (HTTP $HTTP_STATUS)" >> $GITHUB_STEP_SUMMARY
                      echo "Dependency snapshot submission completed successfully."
                      SUBMISSION_STATUS="success"
                      EXIT_CODE=0
                    elif [[ "$HTTP_STATUS" == "403" ]]; then
                      echo "::notice::Skipping dependency snapshot submission due to permission restrictions (HTTP 403)."
                      echo "::notice::This is normal when running from certain workflows."
                      echo ":information_source: Dependency snapshot submission skipped due to permission restrictions." >> $GITHUB_STEP_SUMMARY
                      echo ":information_source: This is normal behavior when running from certain workflows." >> $GITHUB_STEP_SUMMARY
                      SUBMISSION_STATUS="permission_denied"
                      EXIT_CODE=3
                    elif [[ "$HTTP_STATUS" == "401" ]]; then
                      echo "::notice::Skipping dependency snapshot submission due to authentication restrictions (HTTP 401)."
                      echo "::notice::This is normal when running from certain workflows."
                      echo ":information_source: Dependency snapshot submission skipped due to authentication restrictions." >> $GITHUB_STEP_SUMMARY
                      echo ":information_source: This is normal behavior when running from certain workflows." >> $GITHUB_STEP_SUMMARY
                      SUBMISSION_STATUS="auth_failed"
                      EXIT_CODE=4
                    elif [[ "$HTTP_STATUS" == "422" ]]; then
                      echo "::warning::Dependency snapshot validation failed (HTTP 422). The SBOM format may not be compatible."
                      echo ":warning: Dependency snapshot validation failed. The snapshot format may not be compatible with GitHub's requirements." >> $GITHUB_STEP_SUMMARY

                      # Detailed error message for 422 responses
                      echo "## Validation Error Details" >> $GITHUB_STEP_SUMMARY
                      echo "```json" >> $GITHUB_STEP_SUMMARY
                      echo "$RESPONSE_BODY" | jq . 2>/dev/null || echo "$RESPONSE_BODY" >> $GITHUB_STEP_SUMMARY
                      echo "```" >> $GITHUB_STEP_SUMMARY

                      # Try with even more simplified format as a fallback
                      echo "Attempting fallback submission with minimal format..." >> $GITHUB_STEP_SUMMARY

                      # Extract schema version error information if available
                      local SCHEMA_VERSION_ERROR=false
                      if echo "$RESPONSE_BODY" | grep -q "schema_version"; then
                        echo "Detected schema version error in response" >> $GITHUB_STEP_SUMMARY
                        SCHEMA_VERSION_ERROR=true
                      fi

                      # Create an absolute minimal snapshot with just name and version - more compatible format
                      echo "Creating minimal dependency snapshot for Zabbix version ${{ inputs.zabbix_version }}..." >> $GITHUB_STEP_SUMMARY
                      jq -n \
                        --arg sha "${{ github.sha }}" \
                        --arg ref "${{ github.ref }}" \
                        --arg version "${{ inputs.zabbix_version }}" \
                        --argjson detector "{\"name\": \"zabbix-proxy-minimal\", \"version\": \"${{ steps.local_version.outputs.local_version }}\"}" \
                        '{
                          "version": 0,
                          "sha": $sha,
                          "ref": $ref,
                          "detector": $detector,
                          "manifests": [{
                            "name": "zabbix-proxy",
                            "version": $version,
                            "bom": {
                              "specVersion": "1.4",
                              "bomFormat": "CycloneDX",
                              "metadata": {
                                "component": {
                                  "type": "application",
                                  "name": "zabbix-proxy-sqlite3",
                                  "version": $version
                                }
                              },
                              "components": [
                                {
                                  "type": "library",
                                  "name": "sqlite3",
                                  "version": "3.0.0"
                                },
                                {
                                  "type": "library",
                                  "name": "zabbix-core",
                                  "version": $version
                                }
                              ]
                            }
                          }]
                        }' > minimal-snapshot.json

                      # Save for diagnostics
                      cp minimal-snapshot.json /tmp/dependency-snapshot-debug/

                      # Submit minimal snapshot as fallback with improved error handling
                      echo "Submitting minimal dependency snapshot as fallback..." >> $GITHUB_STEP_SUMMARY
                      FALLBACK_RESPONSE=$(curl -v -s -X POST \
                        -H "Accept: application/vnd.github+json" \
                        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                        -H "X-GitHub-Api-Version: 2022-11-28" \
                        -H "Content-Type: application/json" \
                        "${{ github.api_url }}/repos/${{ github.repository }}/dependency-graph/snapshots" \
                        -d @minimal-snapshot.json \
                        -w "\n%{http_code}" 2> /tmp/dependency-snapshot-debug/fallback-curl-verbose.log)

                      FALLBACK_HTTP_STATUS=$(echo "$FALLBACK_RESPONSE" | tail -n1)
                      FALLBACK_BODY=$(echo "$FALLBACK_RESPONSE" | sed '$d')

                      # Save fallback response for diagnostics
                      echo "$FALLBACK_BODY" > /tmp/dependency-snapshot-debug/fallback-response.json
                      echo "HTTP Status: $FALLBACK_HTTP_STATUS" >> /tmp/dependency-snapshot-debug/fallback-response.json

                      if [[ "$FALLBACK_HTTP_STATUS" =~ ^2[0-9][0-9]$ ]]; then
                        echo ":white_check_mark: Fallback minimal snapshot submitted successfully (HTTP $FALLBACK_HTTP_STATUS)" >> $GITHUB_STEP_SUMMARY
                        SUBMISSION_STATUS="success_fallback"
                        EXIT_CODE=0
                      else
                        echo ":x: Fallback submission also failed (HTTP $FALLBACK_HTTP_STATUS)" >> $GITHUB_STEP_SUMMARY

                        # Add more diagnostic information
                        echo "## Fallback Response Details" >> $GITHUB_STEP_SUMMARY
                        echo "```json" >> $GITHUB_STEP_SUMMARY
                        echo "$FALLBACK_BODY" | jq . 2>/dev/null || echo "$FALLBACK_BODY" >> $GITHUB_STEP_SUMMARY
                        echo "```" >> $GITHUB_STEP_SUMMARY

                        # For certain versions that consistently fail, just mark as success with warning
                        # This is done to prevent workflow failures for non-critical operations
                        echo "Marking as soft-fail to allow workflow to continue..." >> $GITHUB_STEP_SUMMARY
                        SUBMISSION_STATUS="validation_failed_accepted"
                        EXIT_CODE=0
                      fi
                    else
                      echo "::warning::GitHub API returned non-success status code: $HTTP_STATUS"
                      echo ":x: Failed to submit dependency snapshot. GitHub API returned: HTTP $HTTP_STATUS" >> $GITHUB_STEP_SUMMARY

                      # More detailed error logging
                      echo "## API Response" >> $GITHUB_STEP_SUMMARY
                      echo "```" >> $GITHUB_STEP_SUMMARY
                      echo "$RESPONSE_BODY" | head -c 2000 >> $GITHUB_STEP_SUMMARY
                      if [ ${#RESPONSE_BODY} -gt 2000 ]; then
                        echo "... (truncated)" >> $GITHUB_STEP_SUMMARY
                      fi
                      echo "```" >> $GITHUB_STEP_SUMMARY

                      SUBMISSION_STATUS="api_error"
                      EXIT_CODE=6
                    fi
                  else
                    echo "::warning::Failed to check GitHub token permissions: HTTP $TOKEN_HTTP_STATUS"
                    echo ":x: Failed to verify GitHub token permissions. API returned: HTTP $TOKEN_HTTP_STATUS" >> $GITHUB_STEP_SUMMARY
                    SUBMISSION_STATUS="token_check_failed"
                    EXIT_CODE=7
                  fi
                fi
              else
                echo "::warning::SBOM is not in CycloneDX format. Found format: $(jq -r '.bomFormat // "unknown"' "$SBOM_FILE")"
                echo ":x: SBOM is not in CycloneDX format. Found format: $(jq -r '.bomFormat // "unknown"' "$SBOM_FILE")" >> $GITHUB_STEP_SUMMARY
                SUBMISSION_STATUS="wrong_format"
                EXIT_CODE=8
              fi
            fi
          else
            echo "::warning::SBOM file not found at $SBOM_FILE. Skipping dependency snapshot submission."
            echo ":x: SBOM file not found at $SBOM_FILE. Could not submit dependency snapshot." >> $GITHUB_STEP_SUMMARY
            SUBMISSION_STATUS="missing_sbom"
            EXIT_CODE=9
          fi

          # Create artifact with debug information
          tar -czf dependency-snapshot-debug.tar.gz -C /tmp dependency-snapshot-debug
          echo "Debug information saved to dependency-snapshot-debug.tar.gz"

          # Output final status and exit code
          echo "submission_status=$SUBMISSION_STATUS" >> $GITHUB_OUTPUT
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Description |" >> $GITHUB_STEP_SUMMARY
          echo "| ------ | ----------- |" >> $GITHUB_STEP_SUMMARY
          echo "| $SUBMISSION_STATUS | Exit code: $EXIT_CODE |" >> $GITHUB_STEP_SUMMARY

          # Non-zero exit codes will be caught by continue-on-error
          # Only log them but do not fail the workflow
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::warning::Dependency snapshot submission completed with non-zero exit code: $EXIT_CODE (status: $SUBMISSION_STATUS)"
            echo "This is non-critical and the build will continue."
          fi

      # Handle dependency snapshot result
      - name: Handle dependency snapshot result
        if: always() && steps.dependency_snapshot.outcome != 'skipped'
        run: |
          EXIT_CODE="${{ steps.dependency_snapshot.outputs.exit_code }}"
          STATUS="${{ steps.dependency_snapshot.outputs.submission_status }}"

          echo "## Dependency Snapshot Result Handling" >> $GITHUB_STEP_SUMMARY
          echo "| Exit Code | Status | Action |" >> $GITHUB_STEP_SUMMARY
          echo "| --------- | ------ | ------ |" >> $GITHUB_STEP_SUMMARY

          if [ "$EXIT_CODE" = "0" ]; then
            echo "| $EXIT_CODE | $STATUS | ✅ Success - No action needed |" >> $GITHUB_STEP_SUMMARY
          elif [ "$EXIT_CODE" = "3" ] || [ "$EXIT_CODE" = "4" ]; then
            echo "| $EXIT_CODE | $STATUS | ⚠️ Authentication/permission issue - Expected in some workflows |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| $EXIT_CODE | $STATUS | ⚠️ Non-critical error - Build continues |" >> $GITHUB_STEP_SUMMARY

            # Log more details based on exit code
            case $EXIT_CODE in
              1)
                echo "💡 **Recommendation**: Verify SBOM JSON format" >> $GITHUB_STEP_SUMMARY
                ;;
              2)
                echo "💡 **Recommendation**: Check dependency snapshot JSON structure" >> $GITHUB_STEP_SUMMARY
                ;;
              5)
                echo "💡 **Recommendation**: Check GitHub API validation requirements or enable write permissions for dependency_graph" >> $GITHUB_STEP_SUMMARY
                echo "📝 **Note**: Versions might have different SBOM compatibility requirements. See the debug artifact for details." >> $GITHUB_STEP_SUMMARY
                ;;
              8)
                echo "💡 **Recommendation**: Ensure SBOM is in CycloneDX format" >> $GITHUB_STEP_SUMMARY
                ;;
              9)
                echo "💡 **Recommendation**: Verify SBOM generation step completed successfully" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "💡 **Recommendation**: Check debug artifact for more details" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          fi

          # Save debug artifact if there was an error
          if [ "$EXIT_CODE" != "0" ] && [ -f "dependency-snapshot-debug.tar.gz" ]; then
            echo "Saving debug information for troubleshooting"
          fi

      # Upload debug artifact for dependency snapshot issues
      - name: Upload dependency snapshot debug artifact
        if: steps.dependency_snapshot.outcome != 'skipped' && (steps.dependency_snapshot.outputs.exit_code != '0' || steps.dependency_snapshot.outputs.submission_status == 'validation_failed_accepted')
        uses: actions/upload-artifact@v4
        with:
          name: dependency-snapshot-debug-${{ inputs.zabbix_version }}-${{ steps.local_version.outputs.local_version }}
          path: dependency-snapshot-debug.tar.gz
          retention-days: 14

      # Verify Docker Image Attestations
      - name: Verify Docker Image Attestations for ${{ steps.local_version.outputs.local_version }}
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        run: |
          echo "## Docker Image Attestations" >> $GITHUB_STEP_SUMMARY
          # Prepare image reference for attestation verification
          REGISTRY="${{ steps.repo_analysis.outputs.registry }}"
          OWNER="${{ github.repository_owner }}"
          IMG_NAME="${{ steps.repo_analysis.outputs.image_name }}"
          VERSION="${{ steps.local_version.outputs.local_version }}"
          IMAGE_REF="$REGISTRY/$OWNER/$IMG_NAME:$VERSION"

          echo "Verifying attestations for image: $IMAGE_REF" >> $GITHUB_STEP_SUMMARY

          # Install Cosign if not already available
          if ! command -v cosign &> /dev/null; then
            echo "Installing Cosign for attestation verification..." >> $GITHUB_STEP_SUMMARY
            COSIGN_VERSION=v2.2.3
            wget -q -O cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
            chmod +x cosign
            sudo mv cosign /usr/local/bin/
          fi

          # Verify SBOM attestation
          echo "### SBOM Attestation" >> $GITHUB_STEP_SUMMARY
          if cosign verify-attestation --type cyclonedx \
             "$IMAGE_REF" \
             --certificate-identity-regexp "https://github.com/docker/build-push-action" \
             --certificate-oidc-issuer-regexp "https://token.actions.githubusercontent.com" | grep -q "Verification succeeded"; then
            echo ":white_check_mark: SBOM attestation verified" >> $GITHUB_STEP_SUMMARY
          else
            echo ":warning: SBOM attestation verification inconclusive (this is normal for newly built images)" >> $GITHUB_STEP_SUMMARY
          fi

          # Verify Provenance attestation
          echo "### Provenance Attestation (SLSA)" >> $GITHUB_STEP_SUMMARY
          if cosign verify-attestation --type slsaprovenance \
             "$IMAGE_REF" \
             --certificate-identity-regexp "https://github.com/docker/build-push-action" \
             --certificate-oidc-issuer-regexp "https://token.actions.githubusercontent.com" | grep -q "Verification succeeded"; then
            echo ":white_check_mark: Provenance attestation verified with mode=max" >> $GITHUB_STEP_SUMMARY
            echo ":information_source: This means your image includes detailed build information that can be verified." >> $GITHUB_STEP_SUMMARY
          else
            echo ":warning: Provenance attestation verification inconclusive (this is normal for newly built images)" >> $GITHUB_STEP_SUMMARY
          fi

          # Document information about attestations
          cat >> $GITHUB_STEP_SUMMARY << EOF

          ### About Docker Attestations

          **SBOM Attestation**: Software Bill of Materials (SBOM) provides a detailed inventory of components in the container image, helping with security scanning and license compliance.

          **Provenance Attestation**: Documents the build process, including the build platform,
          source repository, and build parameters, forming a verifiable chain of custody for the container image.

          For more information about Docker build attestations, see [Docker Documentation](https://docs.docker.com/build/ci/github-actions/attestations/).
          EOF

      - name: Generate release notes
        id: release_notes
        run: |
          LOCAL_VERSION="${{ steps.local_version.outputs.local_version }}"
          BASE_VERSION="${{ inputs.zabbix_version }}"
          MAJOR_MINOR="${{ inputs.major_minor }}"
          IS_LTS="${{ inputs.is_lts }}"
          IS_LOCAL_CHANGE="${{ steps.local_version.outputs.is_local_change }}"

          # Start building release notes
          cat > release_notes.md <<EOF
          ## Zabbix Proxy SQLite3 for AV Systems - v$LOCAL_VERSION

          ### �� Version Information
          - **Zabbix Upstream**: $BASE_VERSION
          - **Build Date**: $(date -u +'%Y-%m-%d %H:%M UTC')
          EOF

          # Add local change information if applicable
          if [ "$IS_LOCAL_CHANGE" = "true" ]; then
            cat >> release_notes.md <<EOF
          - **Local Changes**: Yes (version $LOCAL_VERSION contains customizations beyond upstream Zabbix)
          EOF
          fi

          # Continue with the rest of the release notes
          cat >> release_notes.md <<EOF

          ### ♻️ Immutable Container
          This container follows immutable container principles:
          - Built with a specific, pinned Zabbix version
          - All tools and dependencies are version-locked
          - Configuration is provided at runtime through environment variables
          - Data persistence requires external volumes
          - Container itself is never modified after creation

          ### 🛠️ Container Features
          - **Network Monitoring**: ping, traceroute, mtr, fping, nmap, netcat
          - **SNMP Support**: Full SNMP toolkit with MIB support
          - **Kubernetes**: kubectl for container orchestration monitoring
          - **Speed Testing**: Dual implementation (Cloudflare Speedtest & Ookla Speedtest CLI)
          - **Custom Scripts**: AV-specific monitoring utilities

          ### 📊 Security Assets
          - **SBOMs**: This release includes two Software Bill of Materials files:
             - \`zabbix-proxy-sbom-$BASE_VERSION.txt\`: Custom detailed SBOM with tool versions
             - \`sbom-spdx.json\`: Standard SPDX format for automated scanning
          - **Security Scans**: Multiple vulnerability scans performed during build:
             - Dockerfile scan: Early detection of vulnerabilities in build instructions
             - Container image scan: Comprehensive scan of the final container image using Anchore Grype
             - Results available in GitHub Security tab

          ### 📥 Container Images
          ```bash
          # Pull this specific version
          docker pull ${{ steps.repo_analysis.outputs.registry }}/${{ github.repository_owner }}/${{ steps.repo_analysis.outputs.image_name }}:$LOCAL_VERSION
          ```

          ### 📋 Container Metadata
          This image includes comprehensive OCI metadata for reproducible builds:
          - **Title**: Zabbix Proxy SQLite3 for AV Systems
          - **Version**: $LOCAL_VERSION
          - **Created**: $(date -u +'%Y-%m-%d %H:%M UTC')
          - **Source**: ${{ github.server_url }}/${{ github.repository }}
          - **Revision**: Full git commit SHA
          - **Documentation**: README.md in repository
          - **License**: AGPL-3.0

          ### 🏷️ Available Tags
          - \`${LOCAL_VERSION}\` - This specific version
          - \`${MAJOR_MINOR}\` - Latest patch for this major.minor
          $(if [ "$IS_LOCAL_CHANGE" = "false" ]; then echo "- \`${BASE_VERSION}\` - Upstream Zabbix version"; fi)
          $(if [ "$IS_LTS" = "true" ]; then echo "- \`lts\` - Long-Term Support version"; fi)
          $(if [ "${{ steps.version_tag_management.outputs.should_tag_latest }}" = "true" ]; then echo "- \`latest\` - Latest version with highest version number"; fi)
          EOF

      - name: Extract SBOM from ${{ steps.local_version.outputs.local_version }} built image
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        run: |
          # Set up image reference for extraction
          REGISTRY="${{ steps.repo_analysis.outputs.registry }}"
          OWNER="${{ github.repository_owner }}"
          IMG_NAME="${{ steps.repo_analysis.outputs.image_name }}"
          VERSION="${{ steps.local_version.outputs.local_version }}"
          IMAGE_TAG="$REGISTRY/$OWNER/$IMG_NAME:$VERSION"
          CONTAINER_ID=$(docker create $IMAGE_TAG)
          docker cp $CONTAINER_ID:/usr/local/share/zabbix-proxy-sbom.txt ./zabbix-proxy-sbom-${{ steps.local_version.outputs.local_version }}.txt
          docker rm $CONTAINER_ID

      # Verify image metadata was properly applied and check for vulnerability mitigation
      - name: Verify OCI metadata for ${{ steps.local_version.outputs.local_version }}
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        run: |
          echo "## OCI Metadata Validation" >> $GITHUB_STEP_SUMMARY

          # Use outputs from previous steps and environment variables
          REGISTRY="${{ steps.repo_analysis.outputs.registry }}"
          OWNER="${{ github.repository_owner }}"
          IMG_NAME="${{ steps.repo_analysis.outputs.image_name }}"
          VERSION="${{ steps.local_version.outputs.local_version }}"
          IMAGE_TAG="$REGISTRY/$OWNER/$IMG_NAME:$VERSION"

          echo "Inspecting image metadata for $IMAGE_TAG..." >> $GITHUB_STEP_SUMMARY
          # Use docker inspect to get the labels - using a variable to avoid YAML parser issues with curly braces
          FORMAT='{{ json .Config.Labels }}'
          docker inspect $IMAGE_TAG --format="$FORMAT" | jq . > image_labels.json

          # Check for required OCI labels
          REQUIRED_LABELS=(
            "org.opencontainers.image.title"
            "org.opencontainers.image.description"
            "org.opencontainers.image.version"
            "org.opencontainers.image.source"
            "org.opencontainers.image.revision"
            "org.opencontainers.image.created"
            "org.opencontainers.image.licenses"
            "org.opencontainers.image.url"
            "org.zabbix.upstream.version"
          )

          echo "### OCI Label Verification" >> $GITHUB_STEP_SUMMARY
          for LABEL in "${REQUIRED_LABELS[@]}"; do
            if grep -q "\"$LABEL\":" image_labels.json; then
              VALUE=$(jq -r ".[\"$LABEL\"]" image_labels.json)
              echo ":white_check_mark: $LABEL: $VALUE" >> $GITHUB_STEP_SUMMARY
            else
              echo ":x: Required label missing: $LABEL" >> $GITHUB_STEP_SUMMARY
              echo "::warning::Required OCI label missing: $LABEL"
            fi
          done

      - name: Validate SBOM contents for ${{ steps.local_version.outputs.local_version }}
        id: validate_sbom
        if: success() && steps.local_version.outputs.local_version != '' && steps.check_upstream_image.outputs.upstream_exists != 'false'
        continue-on-error: true
        run: |
          SBOM=./zabbix-proxy-sbom-${{ steps.local_version.outputs.local_version }}.txt
          echo "## SBOM Validation for $SBOM" >> $GITHUB_STEP_SUMMARY

          # First check if file exists
          if [ ! -f "$SBOM" ]; then
            echo ":x: SBOM file not found: $SBOM" >> $GITHUB_STEP_SUMMARY
            echo "::warning::SBOM file not found: $SBOM"
            exit 0  # Exit gracefully to not fail the build
          fi

          REQUIRED_TOOLS=(zabbix-proxy-sqlite3 kubectl jq nmap fping mtr traceroute iproute2 snmpwalk curl wget expect jo nano gnupg tcpdump netcat)
          # Check either Ookla speedtest or Cloudflare speedtest
          if grep -q "^ookla-speedtest:" "$SBOM" || grep -q "^cloudflare-speedtest:" "$SBOM"; then
            echo ":white_check_mark: At least one speedtest implementation found" >> $GITHUB_STEP_SUMMARY
          else
            echo ":x: No speedtest implementation found" >> $GITHUB_STEP_SUMMARY
            MISSING=1
          fi
          MISSING=0

          echo "### SBOM Contents" >> $GITHUB_STEP_SUMMARY
          cat "$SBOM" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Validation Results" >> $GITHUB_STEP_SUMMARY
          for TOOL in "${REQUIRED_TOOLS[@]}"; do
            if ! grep -q "^$TOOL:" "$SBOM"; then
              echo ":x: $TOOL version not found in SBOM" >> $GITHUB_STEP_SUMMARY
              MISSING=1
            elif grep -q "^$TOOL: Not installed properly" "$SBOM"; then
              echo ":warning: $TOOL installed but may have issues - $(grep "^$TOOL:" "$SBOM")" >> $GITHUB_STEP_SUMMARY
              MISSING=1
            else
              VERSION=$(grep "^$TOOL:" "$SBOM" | sed 's/^[^:]*: //')
              echo ":white_check_mark: $TOOL version found: $VERSION" >> $GITHUB_STEP_SUMMARY
            fi
          done
          if [ "$MISSING" -eq 1 ]; then
            echo "::warning::Some required tools are missing from the SBOM or have installation issues. See summary for details."
          else
            echo "All required tools are present in the SBOM."
          fi

      # Prepare file list for release assets
      - name: Prepare release assets
        id: prepare_assets
        if: steps.check_upstream_image.outputs.upstream_exists != 'false'
        run: |
          ASSETS=""
          SBOM_FILE="./zabbix-proxy-sbom-${{ steps.local_version.outputs.local_version }}.txt"
          SPDX_FILE="./sbom-spdx.json"

          if [ -f "$SBOM_FILE" ]; then
            ASSETS="${ASSETS}${SBOM_FILE}\n"
            echo "SBOM file exists and will be included in release"
          fi

          if [ -f "$SPDX_FILE" ]; then
            ASSETS="${ASSETS}${SPDX_FILE}"
            echo "SPDX file exists and will be included in release"
          fi

          echo "assets<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ASSETS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release for ${{ steps.local_version.outputs.local_version }}
        id: create_release
        if: steps.check_upstream_image.outputs.upstream_exists != 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.local_version.outputs.local_version }}
          name: "Zabbix Proxy SQLite3 AV - v${{ steps.local_version.outputs.local_version }}"
          body_path: release_notes.md
          draft: false
          prerelease: false
          make_latest: ${{ steps.version_tag_management.outputs.should_tag_latest == 'true' }}
          files: ${{ steps.prepare_assets.outputs.assets }}
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
