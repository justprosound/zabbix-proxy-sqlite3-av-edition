name: Build Historical Versions

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: 'Minimum version to start building from (e.g. 7.0.0)'
        required: true
        default: '7.0.0'
      force_rebuild:
        description: 'Force rebuild even if image already exists'
        required: false
        type: boolean
        default: false
      custom_image_name:
        description: 'Optional custom image name (e.g. "my-registry.com/user/repo")'
        required: false
        default: ''

# Security: Minimal required permissions
permissions:
  contents: write
  packages: write
  actions: read
  id-token: write
  security-events: write  # For security scanning

env:
  # Security: Define allowed registries
  ALLOWED_REGISTRIES: "ghcr.io"
  REGISTRY: "ghcr.io"
  # Default repo name, overridable via custom_image_name
  REPO_NAME: "zabbix-proxy-sqlite3"
  # Default base name for documentation and references
  BASE_NAME: "Zabbix Proxy SQLite3 AV Edition"
  # Docker Hub upstream repository
  UPSTREAM_REPO: "zabbix/zabbix-proxy-sqlite3"

jobs:
  # Step 1: Get all supported Zabbix versions from API
  get-supported-versions:
    uses: ./.github/workflows/_version-detection.yml

  # Step 2: Get all Docker Hub tags matching our pattern
  get-dockerhub-tags:
    uses: ./.github/workflows/_dockerhub-tags.yml
    with:
      repo: "zabbix/zabbix-proxy-sqlite3"
      tag_pattern: '^ubuntu-[0-9]+\.[0-9]+\.[0-9]+$'
      min_version: "${{ inputs.min_version }}"

  # Step 3: Filter versions to only include those from supported series
  filter-versions:
    needs: [get-supported-versions, get-dockerhub-tags]
    uses: ./.github/workflows/_filter-versions.yml
    with:
      versions: "${{ needs.get-dockerhub-tags.outputs.all_versions }}"
      min_version: "${{ inputs.min_version }}"
      supported_only: true

  # Step 4: Check which images already exist
  check-existing-images:
    needs: filter-versions
    runs-on: ubuntu-latest
    if: ${{ fromJson(needs.filter-versions.outputs.matrix).include[0] != null }}
    strategy:
      matrix: ${{ fromJson(needs.filter-versions.outputs.matrix) }}
      fail-fast: false
    outputs:
      versions_to_build: ${{ steps.collect-versions.outputs.versions_to_build }}
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Get actual repository name from github.repository
            ACTUAL_REPO="${{ github.repository }}"
            ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"

            # Use repo name from actual repository if it doesn't match the default
            if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
              echo "Repository name differs from default, using actual name: $ACTUAL_REPO_NAME"
              # Try to extract a meaningful name - remove common prefixes/suffixes
              CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
              if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" ]]; then
                REPO_NAME="${CLEANED_NAME}-${REPO_NAME}"
              fi
            fi

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Check if image already exists
        id: check-image
        run: |
          ZABBIX_VERSION="${{ matrix.zabbix_version }}"
          IMAGE_TAG="ubuntu-$ZABBIX_VERSION"
          FULL_IMAGE="${{ steps.set-image-name.outputs.image_name }}:$IMAGE_TAG"

          echo "Checking if image $FULL_IMAGE exists"

          # Try to get image manifest
          if docker manifest inspect "$FULL_IMAGE" &>/dev/null; then
            echo "Image $FULL_IMAGE already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image $FULL_IMAGE does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

          # Check if upstream image exists
          UPSTREAM_IMAGE="${{ env.UPSTREAM_REPO }}:ubuntu-$ZABBIX_VERSION"
          if docker manifest inspect "$UPSTREAM_IMAGE" &>/dev/null; then
            echo "Upstream image $UPSTREAM_IMAGE exists"
            echo "upstream_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Upstream image $UPSTREAM_IMAGE does not exist"
            echo "upstream_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set build flag
        id: set-build
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild }}"
          IMAGE_EXISTS="${{ steps.check-image.outputs.exists }}"
          UPSTREAM_EXISTS="${{ steps.check-image.outputs.upstream_exists }}"

          # Build if:
          # 1. Force rebuild is true OR
          # 2. Image doesn't exist AND upstream image exists
          if [[ "$FORCE_REBUILD" == "true" ]] || ([[ "$IMAGE_EXISTS" == "false" ]] && [[ "$UPSTREAM_EXISTS" == "true" ]]); then
            echo "Need to build version ${{ matrix.zabbix_version }}"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Skip building version ${{ matrix.zabbix_version }}"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Collect versions to build
        id: collect-versions
        run: |
          mkdir -p /tmp/versions_to_build

          if [[ "${{ steps.set-build.outputs.should_build }}" == "true" ]]; then
            echo "Adding version ${{ matrix.zabbix_version }} to build list"
            echo "${{ matrix.zabbix_version }}" >> /tmp/versions_to_build/list.txt
          fi

          if [ -f "/tmp/versions_to_build/list.txt" ]; then
            VERSIONS=$(cat /tmp/versions_to_build/list.txt | sort -V | tr '\n' ',' | sed 's/,$//')
            echo "Versions to build: $VERSIONS"
            echo "versions_to_build=$VERSIONS" >> $GITHUB_OUTPUT
          else
            echo "No versions to build"
            echo "versions_to_build=" >> $GITHUB_OUTPUT
          fi

  # Step 5: Expand versions to include all patches
  expand-versions:
    needs: check-existing-images
    if: ${{ needs.check-existing-images.outputs.versions_to_build != '' }}
    uses: ./.github/workflows/_expand-versions.yml
    with:
      versions: ${{ needs.check-existing-images.outputs.versions_to_build }}

  # Step 6: Build expanded versions
  build-versions:
    needs: expand-versions
    if: ${{ fromJson(needs.expand-versions.outputs.matrix).include[0] != null }}
    strategy:
      matrix: ${{ fromJson(needs.expand-versions.outputs.matrix) }}
      fail-fast: false
    uses: ./.github/workflows/_build-container.yml
    with:
      zabbix_version: ${{ matrix.zabbix_version }}
      major_minor: ${{ matrix.major_minor }}
      latest_version: ${{ matrix.zabbix_version }}

  # Step 7: Summary
  summary:
    needs: [get-dockerhub-tags, filter-versions, check-existing-images, expand-versions, build-versions]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
            # Extract repo name from custom image for documentation purposes
            REPO_SHORT_NAME=$(echo "$CUSTOM_IMAGE_NAME" | awk -F'/' '{print $NF}')
            echo "Using custom repo short name: $REPO_SHORT_NAME"
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            REPO_SHORT_NAME="${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Summarize build results
        run: |
          echo "# Historical Version Build Results" >> $GITHUB_STEP_SUMMARY

          # Show image name information
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          echo "## Image Information" >> $GITHUB_STEP_SUMMARY
          echo "Images built with name: **$IMAGE_NAME**" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ inputs.custom_image_name }}" ]; then
            echo "*(Using custom image name provided in workflow inputs)*" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Step 1: Show available versions from Docker Hub
          echo "## Docker Hub Tags" >> $GITHUB_STEP_SUMMARY
          DOCKERHUB_TAG_COUNT=$(echo "${{ needs.get-dockerhub-tags.outputs.all_versions }}" | tr ',' '\n' | wc -l)
          echo "Found $DOCKERHUB_TAG_COUNT tags from Docker Hub for '${{ env.UPSTREAM_REPO }}'" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Step 2: Show filtered versions (supported series)
          echo "## Filtered Versions (Supported Series)" >> $GITHUB_STEP_SUMMARY
          FILTERED_COUNT=$(echo "${{ needs.filter-versions.outputs.filtered_versions }}" | tr ',' '\n' | wc -l)
          echo "Found $FILTERED_COUNT versions from supported series" >> $GITHUB_STEP_SUMMARY

          # Step 3: Show versions selected for building
          echo "## Versions Selected for Building" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ needs.check-existing-images.outputs.versions_to_build }}" ]]; then
            VERSIONS_TO_BUILD=$(echo "${{ needs.check-existing-images.outputs.versions_to_build }}" | tr ',' '\n')
            BUILD_COUNT=$(echo "$VERSIONS_TO_BUILD" | wc -l)
            echo "Selected $BUILD_COUNT versions for building:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$VERSIONS_TO_BUILD" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "No versions needed to be built. All requested versions either:" >> $GITHUB_STEP_SUMMARY
            echo "- Already exist in the registry" >> $GITHUB_STEP_SUMMARY
            echo "- Have no upstream images available" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Step 4: Show expanded versions
          if [[ -n "${{ needs.check-existing-images.outputs.versions_to_build }}" ]]; then
            echo "## Expanded Versions" >> $GITHUB_STEP_SUMMARY
            EXPANDED_VERSIONS=$(echo "${{ needs.expand-versions.outputs.expanded_versions }}" | tr ',' '\n')
            EXPANDED_COUNT=$(echo "$EXPANDED_VERSIONS" | wc -l)
            echo "Expanded to $EXPANDED_COUNT versions (including all patch releases):" >> $GITHUB_STEP_SUMMARY

            # Group by major.minor series
            echo "### Versions by Release Series" >> $GITHUB_STEP_SUMMARY

            # Extract major.minor versions
            MAJOR_MINORS=$(echo "$EXPANDED_VERSIONS" | cut -d. -f1-2 | sort -V -u)

            for MM in $MAJOR_MINORS; do
              # Get all versions for this major.minor
              MM_VERSIONS=$(echo "$EXPANDED_VERSIONS" | grep "^$MM\." | sort -V)
              MM_COUNT=$(echo "$MM_VERSIONS" | wc -l)

              echo "#### $MM Series ($MM_COUNT versions)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$MM_VERSIONS" | tr '\n' ' ' >> $GITHUB_STEP_SUMMARY
              echo '' >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            done

            # Step 5: Show build status
            echo "## Build Status" >> $GITHUB_STEP_SUMMARY
            BUILD_JOB_STATUS="${{ needs.build-versions.result }}"

            case "$BUILD_JOB_STATUS" in
              "success")
                echo "**Build Status**: âœ… All builds completed successfully" >> $GITHUB_STEP_SUMMARY
                ;;
              "failure")
                echo "**Build Status**: âŒ Some builds failed" >> $GITHUB_STEP_SUMMARY
                ;;
              "cancelled")
                echo "**Build Status**: ðŸš« Builds were cancelled" >> $GITHUB_STEP_SUMMARY
                ;;
              "skipped")
                echo "**Build Status**: â­ï¸ Builds were skipped" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "**Build Status**: â³ Builds are in progress or status unknown" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          fi
