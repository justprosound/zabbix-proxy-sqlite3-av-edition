name: Build Historical Versions

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: 'Minimum version to start building from (e.g. 7.0.0)'
        required: true
        default: '7.0.0'
      force_rebuild:
        description: 'Force rebuild even if image already exists'
        required: false
        type: boolean
        default: false
      custom_image_name:
        description: 'Optional custom image name (e.g. "my-registry.com/user/repo")'
        required: false
        default: ''
      build_all_patches:
        description: 'Build all patch versions (0 to latest) for each major.minor series'
        required: false
        type: boolean
        default: false

# Security: Minimal required permissions
permissions:
  contents: write
  packages: write
  actions: read
  id-token: write
  security-events: write  # For security scanning

env:
  # Security: Define allowed registries
  ALLOWED_REGISTRIES: "ghcr.io"
  REGISTRY: "ghcr.io"
  # Default repo name, overridable via custom_image_name
  REPO_NAME: "zabbix-proxy-sqlite3-av-edition"
  # Default base name for documentation and references
  BASE_NAME: "Zabbix Proxy SQLite3 AV Edition"
  # Docker Hub upstream repository
  UPSTREAM_REPO: "zabbix/zabbix-proxy-sqlite3"

jobs:
  # Step 1: Get all supported Zabbix versions from API
  get-supported-versions:
    uses: ./.github/workflows/__version-detection.yml

  # Step 2: Get all Docker Hub tags matching our pattern
  get-dockerhub-tags:
    uses: ./.github/workflows/__dockerhub-tags.yml
    with:
      repo: "zabbix/zabbix-proxy-sqlite3"
      tag_pattern: '^ubuntu-[0-9]+\.[0-9]+\.[0-9]+$'
      min_version: "${{ inputs.min_version }}"

  # Step 3: Process versions and create build matrix
  prepare-build-matrix:
    needs: [get-supported-versions, get-dockerhub-tags]
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      versions_to_build: ${{ steps.generate-matrix.outputs.versions_to_build }}
      target_image: ${{ steps.set-image-name.outputs.image_name }}
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Get actual repository name from github.repository
            ACTUAL_REPO="${{ github.repository }}"
            ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"

            # Use repo name from actual repository if it doesn't match the default
            if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
              echo "Repository name differs from default, using actual name: $ACTUAL_REPO_NAME"
              # Try to extract a meaningful name - remove common prefixes/suffixes
              CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
              if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" ]]; then
                REPO_NAME="${CLEANED_NAME}-${REPO_NAME}"
              fi
            fi

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Filter and process versions
        id: generate-matrix
        run: |
          set -e
          echo "Processing versions..."

          # Get all versions from Docker Hub
          ALL_VERSIONS="${{ needs.get-dockerhub-tags.outputs.all_versions }}"
          if [ -z "$ALL_VERSIONS" ]; then
            echo "No versions found from Docker Hub"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "versions_to_build=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get supported series (major.minor) from Zabbix API
          SUPPORTED_SERIES=$(echo "${{ needs.get-supported-versions.outputs.all_versions }}" | tr ',' '\n' | \
            awk -F. '{print $1"."$2}' | sort -u | tr '\n' '|' | sed 's/|$//')

          echo "Supported series: ${SUPPORTED_SERIES}"

          # Filter versions by supported series
          FILTERED_VERSIONS=$(echo "$ALL_VERSIONS" | tr ',' '\n' | grep -E "^(${SUPPORTED_SERIES})\." | sort -V)

          # Prepare for build matrix
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          VERSIONS_TO_BUILD=()
          BUILD_MATRIX_ITEMS=()

          # Process each version
          echo "$FILTERED_VERSIONS" | while read -r VERSION; do
            # Skip empty lines
            [ -z "$VERSION" ] && continue

            MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1-2)
            IMAGE_TAG="ubuntu-$VERSION"
            FULL_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"
            UPSTREAM_IMAGE="${{ env.UPSTREAM_REPO }}:${IMAGE_TAG}"

            # Check if our image exists
            if docker manifest inspect "$FULL_IMAGE" &>/dev/null; then
              IMAGE_EXISTS="true"
            else
              IMAGE_EXISTS="false"
            fi

            # Check if upstream image exists
            if docker manifest inspect "$UPSTREAM_IMAGE" &>/dev/null; then
              UPSTREAM_EXISTS="true"
            else
              UPSTREAM_EXISTS="false"
              continue  # Skip if upstream doesn't exist
            fi

            # Determine if we should build
            if [[ "${{ inputs.force_rebuild }}" == "true" ]] || ([[ "$IMAGE_EXISTS" == "false" ]] && [[ "$UPSTREAM_EXISTS" == "true" ]]); then
              echo "Will build version $VERSION"

              if [[ "${{ inputs.build_all_patches }}" == "true" ]]; then
                # If building all patches, record the major.minor and highest patch
                # We'll expand these later
                echo "$VERSION" >> /tmp/versions_to_build.txt
              else
                # Just add this specific version to the build list
                echo "{\"zabbix_version\":\"$VERSION\",\"major_minor\":\"$MAJOR_MINOR\"}" >> /tmp/matrix_items.json
              fi
            fi
          done

          # Handle build_all_patches mode
          if [[ "${{ inputs.build_all_patches }}" == "true" ]] && [ -f /tmp/versions_to_build.txt ]; then
            # Group by major.minor and find highest patch for each
            declare -A MAJOR_MINOR_VERSIONS
            while read -r VERSION; do
              MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1-2)
              PATCH=$(echo "$VERSION" | cut -d. -f3)

              # Record highest patch for each major.minor
              if [[ -z "${MAJOR_MINOR_VERSIONS[$MAJOR_MINOR]}" ]] ||
                 [[ $PATCH -gt $(echo "${MAJOR_MINOR_VERSIONS[$MAJOR_MINOR]}" | cut -d. -f3) ]]; then
                MAJOR_MINOR_VERSIONS[$MAJOR_MINOR]="$VERSION"
              fi
            done < /tmp/versions_to_build.txt

            # For each major.minor, expand to all patches
            for MAJOR_MINOR in "${!MAJOR_MINOR_VERSIONS[@]}"; do
              VERSION="${MAJOR_MINOR_VERSIONS[$MAJOR_MINOR]}"
              MAX_PATCH=$(echo "$VERSION" | cut -d. -f3)

              # Generate all patches from 0 to MAX_PATCH
              for ((PATCH=0; PATCH<=MAX_PATCH; PATCH++)); do
                FULL_VERSION="${MAJOR_MINOR}.${PATCH}"

                # Check if upstream image exists for this patch
                UPSTREAM_TAG="ubuntu-$FULL_VERSION"
                if docker manifest inspect "${{ env.UPSTREAM_REPO }}:${UPSTREAM_TAG}" &>/dev/null; then
                  echo "{\"zabbix_version\":\"$FULL_VERSION\",\"major_minor\":\"$MAJOR_MINOR\"}" >> /tmp/matrix_items.json
                fi
              done
            done
          fi

          # Create the final matrix
          if [ -f /tmp/matrix_items.json ]; then
            # Combine all items into a JSON array
            MATRIX_JSON=$(echo '{"include":[' $(cat /tmp/matrix_items.json | tr '\n' ',' | sed 's/,$//') ']}')

            # Get a CSV list of versions for the summary
            VERSIONS_CSV=$(echo "$MATRIX_JSON" | jq -r '.include[].zabbix_version' | tr '\n' ',' | sed 's/,$//')

            echo "Generated build matrix with $(echo "$MATRIX_JSON" | jq '.include | length') versions"
            echo "$MATRIX_JSON" | jq .

            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            echo "versions_to_build=$VERSIONS_CSV" >> $GITHUB_OUTPUT
          else
            echo "No versions need to be built"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "versions_to_build=" >> $GITHUB_OUTPUT
          fi

          # Add to step summary
          echo "## Build Matrix Generation" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| ----------- | ----- |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Hub Tags | $(echo "$ALL_VERSIONS" | tr ',' '\n' | wc -l) |" >> $GITHUB_STEP_SUMMARY
          echo "| Supported Series | $(echo "$SUPPORTED_SERIES" | tr '|' ',' | sed 's/,/, /g') |" >> $GITHUB_STEP_SUMMARY
          echo "| Filtered Versions | $(echo "$FILTERED_VERSIONS" | wc -l) |" >> $GITHUB_STEP_SUMMARY
          if [ -f /tmp/matrix_items.json ]; then
            echo "| Versions to Build | $(cat /tmp/matrix_items.json | wc -l) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Versions to Build | 0 |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| Build All Patches | ${{ inputs.build_all_patches }} |" >> $GITHUB_STEP_SUMMARY

  # Step 4: Build container images
  build-images:
    needs: prepare-build-matrix
    if: ${{ fromJson(needs.prepare-build-matrix.outputs.matrix).include[0] != null }}
    strategy:
      matrix: ${{ fromJson(needs.prepare-build-matrix.outputs.matrix) }}
      fail-fast: false
    uses: ./.github/workflows/__build-container.yml
    with:
      zabbix_version: ${{ matrix.zabbix_version }}
      major_minor: ${{ matrix.major_minor }}
      latest_version: ${{ matrix.zabbix_version }}

  # Step 5: Summary
  summary:
    needs: [get-supported-versions, get-dockerhub-tags, prepare-build-matrix, build-images]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Summarize build results
        run: |
          echo "# Historical Version Build Results" >> $GITHUB_STEP_SUMMARY

          # Show image name information
          IMAGE_NAME="${{ needs.prepare-build-matrix.outputs.target_image }}"
          echo "## Image Information" >> $GITHUB_STEP_SUMMARY
          echo "Images built with name: **$IMAGE_NAME**" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ inputs.custom_image_name }}" ]; then
            echo "*(Using custom image name provided in workflow inputs)*" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show versions information
          echo "## Version Information" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Count |" >> $GITHUB_STEP_SUMMARY
          echo "| ----------- | ----- |" >> $GITHUB_STEP_SUMMARY

          # Docker Hub tags count
          DOCKERHUB_TAG_COUNT=$(echo "${{ needs.get-dockerhub-tags.outputs.all_versions }}" | tr ',' '\n' | grep -v '^$' | wc -l)
          echo "| Docker Hub Tags | $DOCKERHUB_TAG_COUNT |" >> $GITHUB_STEP_SUMMARY

          # Supported versions count
          SUPPORTED_COUNT=$(echo "${{ needs.get-supported-versions.outputs.all_versions }}" | tr ',' '\n' | grep -v '^$' | wc -l)
          echo "| Supported Zabbix Versions | $SUPPORTED_COUNT |" >> $GITHUB_STEP_SUMMARY

          # Versions to build count
          if [[ -n "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" ]]; then
            BUILD_COUNT=$(echo "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" | tr ',' '\n' | grep -v '^$' | wc -l)
            echo "| Versions to Build | $BUILD_COUNT |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Versions to Build | 0 |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Show versions selected for building
          echo "## Versions Selected for Building" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" ]]; then
            VERSIONS_TO_BUILD=$(echo "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" | tr ',' '\n')

            # Group by major.minor series for better readability
            echo "### By Release Series" >> $GITHUB_STEP_SUMMARY

            # Extract major.minor versions
            MAJOR_MINORS=$(echo "$VERSIONS_TO_BUILD" | cut -d. -f1-2 | sort -V -u)

            for MM in $MAJOR_MINORS; do
              # Get all versions for this major.minor
              MM_VERSIONS=$(echo "$VERSIONS_TO_BUILD" | grep "^$MM\." | sort -V)
              MM_COUNT=$(echo "$MM_VERSIONS" | wc -l)

              echo "#### $MM Series ($MM_COUNT versions)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$MM_VERSIONS" | tr '\n' ' ' >> $GITHUB_STEP_SUMMARY
              echo '' >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "No versions needed to be built. All requested versions either:" >> $GITHUB_STEP_SUMMARY
            echo "- Already exist in the registry" >> $GITHUB_STEP_SUMMARY
            echo "- Have no upstream images available" >> $GITHUB_STEP_SUMMARY
            echo "- Are not in a supported Zabbix major.minor series" >> $GITHUB_STEP_SUMMARY
          fi

          # Show build status
          echo "## Build Status" >> $GITHUB_STEP_SUMMARY
          BUILD_JOB_STATUS="${{ needs.build-images.result }}"

          case "$BUILD_JOB_STATUS" in
            "success")
              echo "**Build Status**: âœ… All builds completed successfully" >> $GITHUB_STEP_SUMMARY
              ;;
            "failure")
              echo "**Build Status**: âŒ Some builds failed" >> $GITHUB_STEP_SUMMARY
              ;;
            "cancelled")
              echo "**Build Status**: ðŸš« Builds were cancelled" >> $GITHUB_STEP_SUMMARY
              ;;
            "skipped")
              echo "**Build Status**: â­ï¸ Builds were skipped (no versions to build)" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "**Build Status**: â³ Builds are in progress or status unknown" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
