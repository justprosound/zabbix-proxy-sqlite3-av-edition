name: Build Historical Versions

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: 'Minimum version to start building from (e.g. 7.0.0)'
        required: true
        default: '7.0.0'
      force_rebuild:
        description: 'Force rebuild even if image already exists'
        required: false
        type: boolean
        default: false
      custom_image_name:
        description: 'Optional custom image name (e.g. "my-registry.com/user/repo")'
        required: false
        default: ''
      build_all_patches:
        description: 'Build all patch versions (0 to latest) for each major.minor series'
        required: false
        type: boolean
        default: false

# Ensure we don't run concurrent workflows of the same type
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Security: Minimal required permissions
permissions:
  contents: write
  packages: write
  actions: read
  id-token: write
  security-events: write  # For security scanning

env:
  # Security: Define allowed registries
  ALLOWED_REGISTRIES: "ghcr.io"
  REGISTRY: "ghcr.io"
  # Default repo name, overridable via custom_image_name
  REPO_NAME: "zabbix-proxy-sqlite3-av-edition"
  # Default base name for documentation and references
  BASE_NAME: "Zabbix Proxy SQLite3 AV Edition"
  # Docker Hub upstream repository
  UPSTREAM_REPO: "zabbix/zabbix-proxy-sqlite3"

jobs:
  # Step 1: Get all supported Zabbix versions from API
  get-supported-versions:
    uses: ./.github/workflows/__version-detection.yml

  # Step 2: Get all Docker Hub tags matching our pattern
  get-dockerhub-tags:
    uses: ./.github/workflows/__dockerhub-tags.yml
    with:
      repo: "zabbix/zabbix-proxy-sqlite3"
      tag_pattern: '^ubuntu-[0-9]+\.[0-9]+\.[0-9]+$'
      min_version: "${{ inputs.min_version }}"

  # Step 3: Process versions and create build matrix
  prepare-build-matrix:
    needs: [get-supported-versions, get-dockerhub-tags]
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      versions_to_build: ${{ steps.generate-matrix.outputs.versions_to_build }}
      target_image: ${{ steps.set-image-name.outputs.image_name }}
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Get actual repository name from github.repository
            ACTUAL_REPO="${{ github.repository }}"
            ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"

            # Use repo name from actual repository if it doesn't match the default
            if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
              echo "Repository name differs from default, using actual name: $ACTUAL_REPO_NAME"
              # Try to extract a meaningful name - remove common prefixes/suffixes
              CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
              if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" ]]; then
                REPO_NAME="${CLEANED_NAME}-${REPO_NAME}"
              fi
            fi

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Install parallel and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y parallel jq

      - name: Filter and process versions
        id: generate-matrix
        run: |
          set -e
          echo "Processing versions..."

          # Get all versions from Docker Hub
          ALL_VERSIONS="${{ needs.get-dockerhub-tags.outputs.all_versions }}"
          if [ -z "$ALL_VERSIONS" ]; then
            echo "No versions found from Docker Hub"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "versions_to_build=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get supported series (major.minor) from Zabbix API
          SUPPORTED_VERSIONS="${{ needs.get-supported-versions.outputs.all_versions }}"

          # Convert comma-separated values to JSON arrays for easier processing
          ALL_VERSIONS_JSON=$(echo "$ALL_VERSIONS" | tr ',' '\n' | jq -R . | jq -s .)
          SUPPORTED_VERSIONS_JSON=$(echo "$SUPPORTED_VERSIONS" | tr ',' '\n' | jq -R . | jq -s .)

          # Extract major.minor from supported versions to create a filter
          SUPPORTED_SERIES_JSON=$(echo "$SUPPORTED_VERSIONS_JSON" | jq '[.[] | split(".")[0:2] | join(".")]' | jq 'unique')
          echo "Supported series: $(echo "$SUPPORTED_SERIES_JSON" | jq -c .)"

          # Filter versions to only those in supported series
          FILTERED_VERSIONS_JSON=$(echo "$ALL_VERSIONS_JSON $SUPPORTED_SERIES_JSON" | \
            jq -s '
              .[0] as $all_versions |
              .[1] as $supported_series |
              $all_versions |
              map(select(
                . as $version |
                $supported_series |
                map($version | startswith(.)) |
                any
              )) |
              sort_by(
                . | split(".") |
                map(tonumber)
              )
            ')

          # Get image name for checking
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          UPSTREAM_REPO="${{ env.UPSTREAM_REPO }}"
          FORCE_REBUILD="${{ inputs.force_rebuild }}"
          BUILD_ALL_PATCHES="${{ inputs.build_all_patches }}"

          # Create temp files for parallel processing
          TEMP_DIR=$(mktemp -d)
          VERSIONS_FILE="$TEMP_DIR/versions.json"
          RESULTS_FILE="$TEMP_DIR/results.json"

          # Write filtered versions to file for parallel processing
          echo "$FILTERED_VERSIONS_JSON" > "$VERSIONS_FILE"

          # Create empty results file
          echo "[]" > "$RESULTS_FILE"

          echo "Checking image existence in parallel batches..."

          # Process in parallel with GNU parallel
          # This will check each version and output JSON results directly
          cat "$VERSIONS_FILE" | jq -c '.[]' | \
            parallel --jobs 20 --will-cite bash -c '
              VERSION="{}"
              MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1-2)
              IMAGE_TAG="ubuntu-$VERSION"

              # Check if upstream image exists (only make the API call when needed)
              UPSTREAM_EXISTS=false
              if docker manifest inspect "$UPSTREAM_REPO:$IMAGE_TAG" &>/dev/null; then
                UPSTREAM_EXISTS=true
              fi

              # Only check our image if upstream exists and not forcing rebuild
              IMAGE_EXISTS=false
              if [[ "$UPSTREAM_EXISTS" == true && "$FORCE_REBUILD" != "true" ]]; then
                if docker manifest inspect "$IMAGE_NAME:$IMAGE_TAG" &>/dev/null; then
                  IMAGE_EXISTS=true
                fi
              fi

              # Determine if we should build
              SHOULD_BUILD=false
              if [[ "$FORCE_REBUILD" == "true" || ( "$UPSTREAM_EXISTS" == true && "$IMAGE_EXISTS" == false ) ]]; then
                SHOULD_BUILD=true
              fi

              # Output result as JSON
              jq -n --arg version "$VERSION" \
                  --arg major_minor "$MAJOR_MINOR" \
                  --argjson upstream_exists "$UPSTREAM_EXISTS" \
                  --argjson image_exists "$IMAGE_EXISTS" \
                  --argjson should_build "$SHOULD_BUILD" \
                  "{
                    \"zabbix_version\": \$version,
                    \"major_minor\": \$major_minor,
                    \"upstream_exists\": \$upstream_exists,
                    \"image_exists\": \$image_exists,
                    \"should_build\": \$should_build
                  }"
            ' > "$TEMP_DIR/all_results.json"

          # Combine and filter results
          FILTERED_RESULTS=$(cat "$TEMP_DIR/all_results.json" | jq -s '[.[] | select(.should_build == true)]')

          # Handle build_all_patches mode
          if [[ "$BUILD_ALL_PATCHES" == "true" ]]; then
            echo "Processing all patches mode..."

            # Create a lookup table of versions to check
            VERSIONS_TO_CHECK=$(echo "$FILTERED_RESULTS" | jq '[
              # Group by major_minor
              group_by(.major_minor) |
              # For each group
              .[] |
              # Find the highest patch version
              max_by(.zabbix_version | split(".") | .[2] | tonumber) |
              # Extract the information we need
              {
                major_minor: .major_minor,
                max_version: .zabbix_version,
                max_patch: (.zabbix_version | split(".") | .[2] | tonumber)
              }
            ]')

            # Process each major.minor series
            echo "$VERSIONS_TO_CHECK" | jq -c '.[]' | while read -r VERSION_INFO; do
              MAJOR_MINOR=$(echo "$VERSION_INFO" | jq -r '.major_minor')
              MAX_PATCH=$(echo "$VERSION_INFO" | jq -r '.max_patch')

              echo "Processing $MAJOR_MINOR series, patches 0-$MAX_PATCH..."

              # Create all patch versions and check if they should be built
              for ((PATCH=0; PATCH<=MAX_PATCH; PATCH++)); do
                FULL_VERSION="${MAJOR_MINOR}.${PATCH}"
                UPSTREAM_TAG="ubuntu-$FULL_VERSION"

                # Check if upstream image exists
                if docker manifest inspect "$UPSTREAM_REPO:$UPSTREAM_TAG" &>/dev/null; then
                  # Add to results
                  echo "{
                    \"zabbix_version\": \"$FULL_VERSION\",
                    \"major_minor\": \"$MAJOR_MINOR\",
                    \"upstream_exists\": true,
                    \"should_build\": true
                  }" >> "$TEMP_DIR/patch_results.json"
                fi
              done
            done

            # Combine normal results with patch results if any
            if [ -f "$TEMP_DIR/patch_results.json" ]; then
              COMBINED_RESULTS=$(cat "$TEMP_DIR/patch_results.json" | jq -s . | jq --argjson base "$FILTERED_RESULTS" '
                $base + . | unique_by(.zabbix_version)
              ')
              FILTERED_RESULTS="$COMBINED_RESULTS"
            fi
          fi

          # Extract the matrix-compatible format and versions CSV
          MATRIX_JSON=$(echo "$FILTERED_RESULTS" | jq '{
            include: map({
              zabbix_version: .zabbix_version,
              major_minor: .major_minor
            })
          }')

          VERSIONS_CSV=$(echo "$FILTERED_RESULTS" | jq -r '[.[] | .zabbix_version] | join(",")')

          # Output the results
          if [ "$(echo "$MATRIX_JSON" | jq '.include | length')" -gt 0 ]; then
            echo "Generated build matrix with $(echo "$MATRIX_JSON" | jq '.include | length') versions"
            echo "$MATRIX_JSON" | jq .

            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            echo "versions_to_build=$VERSIONS_CSV" >> $GITHUB_OUTPUT
          else
            echo "No versions need to be built"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "versions_to_build=" >> $GITHUB_OUTPUT
          fi

          # Clean up
          rm -rf "$TEMP_DIR"

          # Add to step summary
          echo "## Build Matrix Generation" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| ----------- | ----- |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Hub Tags | $(echo "$ALL_VERSIONS_JSON" | jq 'length') |" >> $GITHUB_STEP_SUMMARY
          echo "| Supported Series | $(echo "$SUPPORTED_SERIES_JSON" | jq 'join(", ")') |" >> $GITHUB_STEP_SUMMARY
          echo "| Filtered Versions | $(echo "$FILTERED_VERSIONS_JSON" | jq 'length') |" >> $GITHUB_STEP_SUMMARY
          echo "| Versions to Build | $(echo "$MATRIX_JSON" | jq '.include | length') |" >> $GITHUB_STEP_SUMMARY
          echo "| Build All Patches | $BUILD_ALL_PATCHES |" >> $GITHUB_STEP_SUMMARY

  # Step 4: Build container images
  build-images:
    needs: prepare-build-matrix
    if: ${{ fromJson(needs.prepare-build-matrix.outputs.matrix).include[0] != null }}
    # Per-version concurrency group to allow parallel builds of different versions
    # but cancel in-progress builds for the same version
    concurrency:
      group: historical-build-${{ matrix.zabbix_version }}-${{ github.ref }}
      cancel-in-progress: true
    strategy:
      matrix: ${{ fromJson(needs.prepare-build-matrix.outputs.matrix) }}
      fail-fast: false
    uses: ./.github/workflows/__build-container.yml
    with:
      zabbix_version: ${{ matrix.zabbix_version }}
      major_minor: ${{ matrix.major_minor }}
      latest_version: ${{ matrix.zabbix_version }}

  # Step 5: Summary
  summary:
    needs: [get-supported-versions, get-dockerhub-tags, prepare-build-matrix, build-images]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Summarize build results
        run: |
          echo "# Historical Version Build Results" >> $GITHUB_STEP_SUMMARY

          # Show image name information
          IMAGE_NAME="${{ needs.prepare-build-matrix.outputs.target_image }}"
          echo "## Image Information" >> $GITHUB_STEP_SUMMARY
          echo "Images built with name: **$IMAGE_NAME**" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ inputs.custom_image_name }}" ]; then
            echo "*(Using custom image name provided in workflow inputs)*" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show versions information
          echo "## Version Information" >> $GITHUB_STEP_SUMMARY
          echo "| Description | Count |" >> $GITHUB_STEP_SUMMARY
          echo "| ----------- | ----- |" >> $GITHUB_STEP_SUMMARY

          # Docker Hub tags count
          DOCKERHUB_TAG_COUNT=$(echo "${{ needs.get-dockerhub-tags.outputs.all_versions }}" | tr ',' '\n' | grep -v '^$' | wc -l)
          echo "| Docker Hub Tags | $DOCKERHUB_TAG_COUNT |" >> $GITHUB_STEP_SUMMARY

          # Supported versions count
          SUPPORTED_COUNT=$(echo "${{ needs.get-supported-versions.outputs.all_versions }}" | tr ',' '\n' | grep -v '^$' | wc -l)
          echo "| Supported Zabbix Versions | $SUPPORTED_COUNT |" >> $GITHUB_STEP_SUMMARY

          # Versions to build count
          if [[ -n "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" ]]; then
            BUILD_COUNT=$(echo "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" | tr ',' '\n' | grep -v '^$' | wc -l)
            echo "| Versions to Build | $BUILD_COUNT |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Versions to Build | 0 |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Show versions selected for building
          echo "## Versions Selected for Building" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" ]]; then
            VERSIONS_TO_BUILD=$(echo "${{ needs.prepare-build-matrix.outputs.versions_to_build }}" | tr ',' '\n')

            # Group by major.minor series for better readability
            echo "### By Release Series" >> $GITHUB_STEP_SUMMARY

            # Extract major.minor versions
            MAJOR_MINORS=$(echo "$VERSIONS_TO_BUILD" | cut -d. -f1-2 | sort -V -u)

            for MM in $MAJOR_MINORS; do
              # Get all versions for this major.minor
              MM_VERSIONS=$(echo "$VERSIONS_TO_BUILD" | grep "^$MM\." | sort -V)
              MM_COUNT=$(echo "$MM_VERSIONS" | wc -l)

              echo "#### $MM Series ($MM_COUNT versions)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$MM_VERSIONS" | tr '\n' ' ' >> $GITHUB_STEP_SUMMARY
              echo '' >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "No versions needed to be built. All requested versions either:" >> $GITHUB_STEP_SUMMARY
            echo "- Already exist in the registry" >> $GITHUB_STEP_SUMMARY
            echo "- Have no upstream images available" >> $GITHUB_STEP_SUMMARY
            echo "- Are not in a supported Zabbix major.minor series" >> $GITHUB_STEP_SUMMARY
          fi

          # Show build status
          echo "## Build Status" >> $GITHUB_STEP_SUMMARY
          BUILD_JOB_STATUS="${{ needs.build-images.result }}"

          case "$BUILD_JOB_STATUS" in
            "success")
              echo "**Build Status**: ✅ All builds completed successfully" >> $GITHUB_STEP_SUMMARY
              ;;
            "failure")
              echo "**Build Status**: ❌ Some builds failed" >> $GITHUB_STEP_SUMMARY
              ;;
            "cancelled")
              echo "**Build Status**: 🚫 Builds were cancelled" >> $GITHUB_STEP_SUMMARY
              ;;
            "skipped")
              echo "**Build Status**: ⏭️ Builds were skipped (no versions to build)" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "**Build Status**: ⏳ Builds are in progress or status unknown" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
