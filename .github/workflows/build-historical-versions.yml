name: Build Historical Versions

on:
  workflow_dispatch:
    inputs:
      min_version:
        description: 'Minimum version to start building from (e.g. 7.0.0)'
        required: true
        default: '7.0.0'
      force_rebuild:
        description: 'Force rebuild even if image already exists'
        required: false
        type: boolean
        default: false
      custom_image_name:
        description: 'Optional custom image name (e.g. "my-registry.com/user/repo")'
        required: false
        default: ''

# Security: Minimal required permissions
permissions:
  contents: write
  packages: write
  actions: read
  id-token: write
  security-events: write  # For security scanning

env:
  # Security: Define allowed registries
  ALLOWED_REGISTRIES: "ghcr.io"
  REGISTRY: "ghcr.io"
  # Default repo name, overridable via custom_image_name
  REPO_NAME: "zabbix-proxy-sqlite3"
  # Default base name for documentation and references
  BASE_NAME: "Zabbix Proxy SQLite3 AV Edition"

jobs:
  fetch-historical-versions:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch Zabbix version data
        run: |
          echo "Fetching data from Zabbix API..."
          mkdir -p .github
          curl -s -f -S "https://services.zabbix.com/updates/v1" > .github/zabbix-versions.json || {
            echo "::error::Failed to fetch Zabbix version data from API"
            exit 1
          }

          # Validate the JSON response
          if ! jq . .github/zabbix-versions.json > /dev/null; then
            echo "::error::Invalid JSON received from Zabbix API"
            cat .github/zabbix-versions.json | head -n 50
            exit 1
          fi

      - name: Generate list of versions since ${{ inputs.min_version }}
        id: generate-matrix
        run: |
          MIN_VERSION="${{ inputs.min_version }}"
          echo "Generating list of versions starting from $MIN_VERSION"

          # Extract all versions, including EOL ones
          ALL_VERSIONS=$(jq -r '.versions[].latest_release.release' .github/zabbix-versions.json | sort -V)

          # Filter versions >= MIN_VERSION
          FILTERED_VERSIONS=$(echo "$ALL_VERSIONS" | awk -v min="$MIN_VERSION" '
            function version_compare(ver1, ver2,    v1, v2, i) {
              # Split versions by "."
              split(ver1, v1, ".");
              split(ver2, v2, ".");

              # Compare each component
              for (i = 1; i <= 3; i++) {
                if (v1[i] + 0 < v2[i] + 0) return -1;
                if (v1[i] + 0 > v2[i] + 0) return 1;
              }
              return 0;
            }

            version_compare($0, min) >= 0 { print $0 }
          ')

          echo "Versions to check: $FILTERED_VERSIONS"

          # Get latest version (highest version number)
          LATEST_VERSION=$(echo "$FILTERED_VERSIONS" | sort -V | tail -n1)

          # Create matrix with version info
          MATRIX_JSON=$(echo "$FILTERED_VERSIONS" | tr ' ' '\n' | grep -v '^$' | jq --arg latest "$LATEST_VERSION" -Rs '
            split("\n")
            | map(select(length > 0))
            | map({
                "zabbix_version": .,
                "major_minor": (split(".") | .[0:2] | join(".") | tostring),
                "is_latest": (if . == $latest then "true" else "false" end)
              })
            | {"include": .}
          ' | tr -d '\n')

          echo "Generated matrix:"
          echo "$MATRIX_JSON" | jq .

          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  check-existing-images:
    needs: fetch-historical-versions
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.fetch-historical-versions.outputs.matrix) }}
      fail-fast: false
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
            # Extract repo name from custom image for documentation purposes
            REPO_SHORT_NAME=$(echo "$CUSTOM_IMAGE_NAME" | awk -F'/' '{print $NF}')
            echo "Using custom repo short name: $REPO_SHORT_NAME"
            echo "repo_short_name=${REPO_SHORT_NAME}" >> $GITHUB_OUTPUT
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Get actual repository name from github.repository
            ACTUAL_REPO="${{ github.repository }}"
            ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"

            # Use repo name from actual repository if it doesn't match the default
            if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
              echo "Repository name differs from default, using actual name: $ACTUAL_REPO_NAME"
              # Try to extract a meaningful name - remove common prefixes/suffixes
              CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
              if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" ]]; then
                REPO_NAME="${CLEANED_NAME}-${REPO_NAME}"
              fi
            fi

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
            echo "repo_short_name=${REPO_NAME}" >> $GITHUB_OUTPUT
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Check if image already exists
        id: check-image
        run: |
          ZABBIX_VERSION="${{ matrix.zabbix_version }}"
          IMAGE_TAG="ubuntu-$ZABBIX_VERSION"
          FULL_IMAGE="${{ steps.set-image-name.outputs.image_name }}:$IMAGE_TAG"

          echo "Checking if image $FULL_IMAGE exists"

          # Try to get image manifest
          if docker manifest inspect "$FULL_IMAGE" &>/dev/null; then
            echo "Image $FULL_IMAGE already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Image $FULL_IMAGE does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

          # Check if upstream image exists
          UPSTREAM_IMAGE="zabbix/zabbix-proxy-sqlite3:ubuntu-$ZABBIX_VERSION"
          if docker manifest inspect "$UPSTREAM_IMAGE" &>/dev/null; then
            echo "Upstream image $UPSTREAM_IMAGE exists"
            echo "upstream_exists=true" >> $GITHUB_OUTPUT
          else
            echo "Upstream image $UPSTREAM_IMAGE does not exist"
            echo "upstream_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set build flag
        id: set-build
        run: |
          FORCE_REBUILD="${{ inputs.force_rebuild }}"
          IMAGE_EXISTS="${{ steps.check-image.outputs.exists }}"
          UPSTREAM_EXISTS="${{ steps.check-image.outputs.upstream_exists }}"

          # Build if:
          # 1. Force rebuild is true OR
          # 2. Image doesn't exist AND upstream image exists
          if [[ "$FORCE_REBUILD" == "true" ]] || ([[ "$IMAGE_EXISTS" == "false" ]] && [[ "$UPSTREAM_EXISTS" == "true" ]]); then
            echo "Need to build version ${{ matrix.zabbix_version }}"
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            echo "Skip building version ${{ matrix.zabbix_version }}"
            echo "should_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Collect versions to build
        if: steps.set-build.outputs.should_build == 'true'
        run: |
          echo "${{ matrix.zabbix_version }}" >> /tmp/versions_to_build.txt

      - name: Upload versions to build
        if: steps.set-build.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: versions-to-build-${{ matrix.zabbix_version }}
          path: /tmp/versions_to_build.txt
          retention-days: 1

  collect-missing-versions:
    needs: check-existing-images
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts
          pattern: versions-to-build-*
          merge-multiple: true

      - name: Collect versions to build
        id: generate-matrix
        run: |
          if [ -d "/tmp/artifacts" ] && [ -f "/tmp/artifacts/versions_to_build.txt" ]; then
            VERSIONS=$(cat /tmp/artifacts/versions_to_build.txt 2>/dev/null || echo "")
            if [ -n "$VERSIONS" ]; then
              echo "Found base versions to build: $VERSIONS"

              # Create a temporary directory to hold expanded versions
              mkdir -p /tmp/expanded_versions

              # Process each version to expand its major.minor series
              EXPANDED_VERSIONS=""

              # Process each version - fix subshell issue by using different approach
              while IFS= read -r VERSION; do
                if [ -n "$VERSION" ]; then
                  # Extract major.minor from version
                  MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1-2)
                  PATCH=$(echo "$VERSION" | cut -d. -f3)

                  echo "Processing version $VERSION (Major.Minor: $MAJOR_MINOR, Patch: $PATCH)"

                  # Generate sequence from 0 to patch for this major.minor
                  for ((i=0; i<=$PATCH; i++)); do
                    FULL_VERSION="$MAJOR_MINOR.$i"
                    echo "Adding $FULL_VERSION to check list"
                    echo "$FULL_VERSION" >> /tmp/expanded_versions/all_versions.txt
                  done
                fi
              done <<< "$(echo "$VERSIONS" | sort -V)"

              # Remove duplicates and sort
              if [ -f "/tmp/expanded_versions/all_versions.txt" ]; then
                EXPANDED_VERSIONS=$(sort -V -u /tmp/expanded_versions/all_versions.txt)
                echo "Expanded versions to check: $EXPANDED_VERSIONS"

                # Generate JSON matrix with expanded versions
                MATRIX_JSON=$(echo "$EXPANDED_VERSIONS" | jq -Rs '
                  split("\n")
                  | map(select(length > 0))
                  | map({
                      "zabbix_version": .,
                      "major_minor": (split(".") | .[0:2] | join(".") | tostring),
                      "is_latest": "false"
                    })
                  | {"include": .}
                ' | tr -d '\n')

                echo "Generated expanded build matrix:"
                echo "$MATRIX_JSON" | jq .

                echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
              else
                echo "No expanded versions generated"
                echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
              fi
            else
              echo "No versions to build"
              echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
            fi
          else
            echo "No artifacts found"
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
          fi

  build-missing-versions:
    needs: collect-missing-versions
    # Only run if there are versions to build (matrix is not empty)
    if: ${{ fromJson(needs.collect-missing-versions.outputs.matrix).include[0] != null }}
    strategy:
      matrix: ${{ fromJson(needs.collect-missing-versions.outputs.matrix) }}
      fail-fast: false
    uses: ./.github/workflows/_build-container.yml
    with:
      zabbix_version: ${{ matrix.zabbix_version }}
      major_minor: ${{ matrix.major_minor }}
      latest_version: ${{ matrix.zabbix_version }}  # Set to current version

  summary:
    needs: [collect-missing-versions, build-missing-versions]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Set image name
        id: set-image-name
        run: |
          # Check if a custom image name was provided
          CUSTOM_IMAGE_NAME="${{ inputs.custom_image_name }}"

          if [ -n "$CUSTOM_IMAGE_NAME" ]; then
            # Use the custom image name
            IMAGE_NAME="$CUSTOM_IMAGE_NAME"
            echo "Using custom image name: $IMAGE_NAME"
            # Extract repo name from custom image for documentation purposes
            REPO_SHORT_NAME=$(echo "$CUSTOM_IMAGE_NAME" | awk -F'/' '{print $NF}')
            echo "Using custom repo short name: $REPO_SHORT_NAME"
            echo "repo_short_name=${REPO_SHORT_NAME}" >> $GITHUB_OUTPUT
          else
            # Use default naming pattern
            REGISTRY="${{ env.REGISTRY }}"
            REPO_NAME="${{ env.REPO_NAME }}"
            REPO_OWNER="${{ github.repository_owner }}"

            # Get actual repository name from github.repository
            ACTUAL_REPO="${{ github.repository }}"
            ACTUAL_REPO_NAME="${ACTUAL_REPO#*/}"

            # Use repo name from actual repository if it doesn't match the default
            if [[ "$ACTUAL_REPO_NAME" != "zabbix-proxy-sqlite3-av-edition" ]]; then
              echo "Repository name differs from default, using actual name: $ACTUAL_REPO_NAME"
              # Try to extract a meaningful name - remove common prefixes/suffixes
              CLEANED_NAME=$(echo "$ACTUAL_REPO_NAME" | sed -E 's/(zabbix|proxy|sqlite|edition|av)[-_]?//gi' | sed -E 's/[-_]?(zabbix|proxy|sqlite|edition|av)//gi')
              if [[ -n "$CLEANED_NAME" && "$CLEANED_NAME" != "$ACTUAL_REPO_NAME" ]]; then
                REPO_NAME="${CLEANED_NAME}-${REPO_NAME}"
              fi
            fi

            # Set the full image name
            IMAGE_NAME="${REGISTRY}/${REPO_OWNER}/${REPO_NAME}"
            echo "Using default image name: $IMAGE_NAME"
            echo "repo_short_name=${REPO_NAME}" >> $GITHUB_OUTPUT
          fi

          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Summarize build results
        run: |
          echo "# Historical Version Build Results" >> $GITHUB_STEP_SUMMARY

          # Show image name information
          IMAGE_NAME="${{ steps.set-image-name.outputs.image_name }}"
          echo "## Image Information" >> $GITHUB_STEP_SUMMARY
          echo "Images will be built with name: **$IMAGE_NAME**" >> $GITHUB_STEP_SUMMARY

          if [ -n "${{ inputs.custom_image_name }}" ]; then
            echo "*(Using custom image name provided in workflow inputs)*" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          MATRIX='${{ needs.collect-missing-versions.outputs.matrix }}'
          BUILD_JOB_STATUS='${{ needs.build-missing-versions.result }}'

          if [ "$(echo "$MATRIX" | jq '.include | length')" -gt 0 ]; then
            VERSIONS_COUNT=$(echo "$MATRIX" | jq '.include | length')

            echo "## Versions Queued for Building" >> $GITHUB_STEP_SUMMARY
            echo "Total versions to build: $VERSIONS_COUNT" >> $GITHUB_STEP_SUMMARY

            # Show build job status
            case "$BUILD_JOB_STATUS" in
              "success")
                echo "**Build Status**: ✅ All builds completed successfully" >> $GITHUB_STEP_SUMMARY
                ;;
              "failure")
                echo "**Build Status**: ❌ Some builds failed" >> $GITHUB_STEP_SUMMARY
                ;;
              "cancelled")
                echo "**Build Status**: 🚫 Builds were cancelled" >> $GITHUB_STEP_SUMMARY
                ;;
              "skipped")
                echo "**Build Status**: ⏭️ Builds were skipped" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "**Build Status**: ⏳ Builds are in progress or status unknown" >> $GITHUB_STEP_SUMMARY
                ;;
            esac

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This workflow expands each version to build all previous patch releases in the same major.minor series." >> $GITHUB_STEP_SUMMARY
            echo "For example, if version 7.0.9 is selected for building, the workflow will also build versions 7.0.0 through 7.0.8." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Extract and display versions by major.minor groups
            echo "### Versions by Release Series" >> $GITHUB_STEP_SUMMARY

            # Get all major.minor values and sort them
            MAJOR_MINORS=$(echo "$MATRIX" | jq -r '.include[].major_minor' | sort -V -u)

            for MM in $MAJOR_MINORS; do
              # Get all versions for this major.minor
              MM_VERSIONS=$(echo "$MATRIX" | jq -r --arg mm "$MM" '.include[] | select(.major_minor == $mm) | .zabbix_version' | sort -V)
              MM_COUNT=$(echo "$MM_VERSIONS" | wc -l)

              echo "#### $MM Series ($MM_COUNT versions)" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "$MM_VERSIONS" | tr '\n' ' ' >> $GITHUB_STEP_SUMMARY
              echo '' >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "## No versions needed to be built" >> $GITHUB_STEP_SUMMARY
            echo "All requested versions already exist or upstream images are not available." >> $GITHUB_STEP_SUMMARY
          fi
