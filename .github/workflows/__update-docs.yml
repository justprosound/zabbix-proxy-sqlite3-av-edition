name: ◆ reusable | Update Documentation

on:
  workflow_call:
    inputs:
      latest_version:
        required: true
        type: string
      lts_version:
        required: true
        type: string
      all_versions:
        required: true
        type: string

jobs:
  update-docs:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Update README with version table
        id: update_readme
        run: |
          LATEST_VERSION='${{ inputs.latest_version }}'
          LTS_VERSION='${{ inputs.lts_version }}'
          ALL_VERSIONS='${{ inputs.all_versions }}'

          echo "Latest version: $LATEST_VERSION"
          echo "LTS version: $LTS_VERSION"
          echo "All versions: $ALL_VERSIONS"

          if [[ -n "$LATEST_VERSION" && -f "README.md" ]]; then
            echo "Updating README.md with version information..."

            TABLE="## Available Versions"
            TABLE+="\n"
            TABLE+="\n| Version | Tags | Description |"
            TABLE+="\n|---------|------|-------------|"

            for VERSION in $(echo "${ALL_VERSIONS%,}" | tr ',' ' ' | sort -Vr); do
              [[ -z "$VERSION" ]] && continue
              MAJOR=$(echo "$VERSION" | cut -d. -f1)
              MINOR=$(echo "$VERSION" | cut -d. -f2)
              if [[ "$VERSION" == "$LTS_VERSION" ]]; then
                TABLE+="\n| $VERSION | \`lts\`, \`$VERSION\`, \`$MAJOR.$MINOR\` | LTS (Long-Term Support) version |"
              elif [[ "$VERSION" == "$LATEST_VERSION" ]]; then
                TABLE+="\n| $VERSION | \`latest\`, \`$VERSION\`, \`$MAJOR.$MINOR\` | Latest bleeding edge version |"
              else
                TABLE+="\n| $VERSION | \`$VERSION\`, \`$MAJOR.$MINOR\` | Supported version |"
              fi
            done

            TABLE+="\n\n> **Note:** The \`latest\` tag follows Zabbix's upstream latest version ($LATEST_VERSION), while the \`lts\` tag points to the Long-Term Support version ($LTS_VERSION)."

            if grep -q "## Available Versions" README.md; then
              START_LINE=$(grep -n "## Available Versions" README.md | cut -d: -f1)
              NEXT_SECTION=$(tail -n +$((START_LINE + 1)) README.md | grep -n "^## " | head -n1 | cut -d: -f1)
              if [[ -n "$NEXT_SECTION" ]]; then
                END_LINE=$((START_LINE + NEXT_SECTION))
                head -n $((START_LINE - 1)) README.md > README.md.tmp
                echo -e "$TABLE" >> README.md.tmp
                tail -n +$END_LINE README.md >> README.md.tmp
                mv README.md.tmp README.md
              else
                head -n $((START_LINE - 1)) README.md > README.md.tmp
                echo -e "$TABLE" >> README.md.tmp
                mv README.md.tmp README.md
              fi
            else
              INTRO_LINE=$(grep -n "It includes a few additional binaries and scripts" README.md | cut -d: -f1)
              if [[ -n "$INTRO_LINE" ]]; then
                head -n "$INTRO_LINE" README.md > README.md.tmp
                echo -e "\n$TABLE" >> README.md.tmp
                tail -n +$((INTRO_LINE + 1)) README.md >> README.md.tmp
                mv README.md.tmp README.md
              fi
            fi
            echo "Updated README.md with version information"
          else
            echo "Warning: No version data or README.md not found"
          fi

      - name: Update GitHub organization references
        id: update_org_refs
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.repository }}"
          REPO_NAME="${REPO_NAME#*/}"
          echo "Repository owner: $REPO_OWNER"
          echo "Repository name: $REPO_NAME"

          # Find all markdown files in the repository (excluding specific paths)
          echo "Finding all markdown files in the repository..."
          MARKDOWN_FILES=$(find . -type f -name "*.md" | grep -v "node_modules\|vendor\|\.git")

          # Counter for modified files
          MODIFIED_COUNT=0

          for file in $MARKDOWN_FILES; do
            echo "Processing $file..."
            # Create a backup of the original file for comparison
            cp "$file" "${file}.bak"

            # Replace explicit GITHUB_USERNAME placeholders
            sed -i -E 's@ghcr\.io/GITHUB_USERNAME/@ghcr\.io/'$REPO_OWNER'/@g' "$file"
            sed -i -E 's@ghcr\.io/GITHUB_USERNAME@ghcr\.io/'$REPO_OWNER'@g' "$file"

            # Handle specific Docker image repository references
            sed -i -E 's@ghcr\.io/[^/]+/'$REPO_NAME'@ghcr\.io/'$REPO_OWNER'/'$REPO_NAME'@g' "$file"

            # Handle repository-owner placeholders with angle brackets
            sed -i -E 's@ghcr\.io/<repository-owner>/@ghcr\.io/'$REPO_OWNER'/@g' "$file"
            sed -i -E 's@github\.com/<repository-owner>/@github\.com/'$REPO_OWNER'/@g' "$file"

            # Handle image name placeholders - using the full repository name for consistency
            if [[ -n "$REPO_NAME" ]]; then
              sed -i -E 's@<derived-image-name>@'$REPO_NAME'@g' "$file"
              sed -i -E 's@zabbix-proxy-sqlite3@'$REPO_NAME'@g' "$file"
            fi

            # Check if the file was modified
            if ! cmp -s "$file" "${file}.bak"; then
              echo "✓ Updated organization references in $file"
              # Show what changed (sample)
              echo "   Changes made (sample):"
              diff -U0 "${file}.bak" "$file" | grep '^[+-][^+-]' | head -10
              MODIFIED_COUNT=$((MODIFIED_COUNT + 1))
            else
              echo "✓ No changes needed in $file"
            fi

            # Remove the backup file
            rm "${file}.bak"
          done

          echo "=== Summary ==="
          echo "Modified $MODIFIED_COUNT markdown files with repository references"

      - name: Commit changes back to repository
        id: commit_changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Find all markdown files that might have changed
          MARKDOWN_FILES=$(find . -type f -name "*.md" | grep -v "node_modules\|vendor\|\.git")

          # Track if we need to commit any changes
          CHANGES_DETECTED=false

          # Check each file for changes
          for file in $MARKDOWN_FILES; do
            if ! git diff --exit-code "$file" > /dev/null 2>&1; then
              echo "Changes detected in $file"
              git add "$file"
              CHANGES_DETECTED=true
            fi
          done

          # Commit if any files changed
          if [ "$CHANGES_DETECTED" = true ]; then
            echo "Committing changes to documentation files..."
            git commit -m "Update documentation with latest version information and repository references"
            git push
            echo "Changes committed and pushed."
          else
            echo "No changes to commit."
          fi
